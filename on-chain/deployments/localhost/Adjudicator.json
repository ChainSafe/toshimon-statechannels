{
  "address": "0x5FbDB2315678afecb367f032d93F642f64180aa3",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "channelId",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "assetIndex",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "initialHoldings",
          "type": "uint256"
        }
      ],
      "name": "AllocationUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "channelId",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint48",
          "name": "newTurnNumRecord",
          "type": "uint48"
        }
      ],
      "name": "ChallengeCleared",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "channelId",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint48",
          "name": "turnNumRecord",
          "type": "uint48"
        },
        {
          "indexed": false,
          "internalType": "uint48",
          "name": "finalizesAt",
          "type": "uint48"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "isFinal",
          "type": "bool"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "chainId",
              "type": "uint256"
            },
            {
              "internalType": "address[]",
              "name": "participants",
              "type": "address[]"
            },
            {
              "internalType": "uint48",
              "name": "channelNonce",
              "type": "uint48"
            },
            {
              "internalType": "address",
              "name": "appDefinition",
              "type": "address"
            },
            {
              "internalType": "uint48",
              "name": "challengeDuration",
              "type": "uint48"
            }
          ],
          "indexed": false,
          "internalType": "struct IForceMove.FixedPart",
          "name": "fixedPart",
          "type": "tuple"
        },
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "asset",
                  "type": "address"
                },
                {
                  "internalType": "bytes",
                  "name": "metadata",
                  "type": "bytes"
                },
                {
                  "components": [
                    {
                      "internalType": "bytes32",
                      "name": "destination",
                      "type": "bytes32"
                    },
                    {
                      "internalType": "uint256",
                      "name": "amount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint8",
                      "name": "allocationType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "bytes",
                      "name": "metadata",
                      "type": "bytes"
                    }
                  ],
                  "internalType": "struct ExitFormat.Allocation[]",
                  "name": "allocations",
                  "type": "tuple[]"
                }
              ],
              "internalType": "struct ExitFormat.SingleAssetExit[]",
              "name": "outcome",
              "type": "tuple[]"
            },
            {
              "internalType": "bytes",
              "name": "appData",
              "type": "bytes"
            },
            {
              "internalType": "uint48",
              "name": "turnNum",
              "type": "uint48"
            },
            {
              "internalType": "bool",
              "name": "isFinal",
              "type": "bool"
            }
          ],
          "indexed": false,
          "internalType": "struct IForceMoveApp.VariablePart[]",
          "name": "variableParts",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "internalType": "uint8",
              "name": "v",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "r",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "s",
              "type": "bytes32"
            }
          ],
          "indexed": false,
          "internalType": "struct IForceMove.Signature[]",
          "name": "sigs",
          "type": "tuple[]"
        },
        {
          "indexed": false,
          "internalType": "uint8[]",
          "name": "whoSignedWhat",
          "type": "uint8[]"
        }
      ],
      "name": "ChallengeRegistered",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "channelId",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint48",
          "name": "finalizesAt",
          "type": "uint48"
        }
      ],
      "name": "Concluded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "destination",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "asset",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountDeposited",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "destinationHoldings",
          "type": "uint256"
        }
      ],
      "name": "Deposited",
      "type": "event"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "chainId",
              "type": "uint256"
            },
            {
              "internalType": "address[]",
              "name": "participants",
              "type": "address[]"
            },
            {
              "internalType": "uint48",
              "name": "channelNonce",
              "type": "uint48"
            },
            {
              "internalType": "address",
              "name": "appDefinition",
              "type": "address"
            },
            {
              "internalType": "uint48",
              "name": "challengeDuration",
              "type": "uint48"
            }
          ],
          "internalType": "struct IForceMove.FixedPart",
          "name": "fixedPart",
          "type": "tuple"
        },
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "asset",
                  "type": "address"
                },
                {
                  "internalType": "bytes",
                  "name": "metadata",
                  "type": "bytes"
                },
                {
                  "components": [
                    {
                      "internalType": "bytes32",
                      "name": "destination",
                      "type": "bytes32"
                    },
                    {
                      "internalType": "uint256",
                      "name": "amount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint8",
                      "name": "allocationType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "bytes",
                      "name": "metadata",
                      "type": "bytes"
                    }
                  ],
                  "internalType": "struct ExitFormat.Allocation[]",
                  "name": "allocations",
                  "type": "tuple[]"
                }
              ],
              "internalType": "struct ExitFormat.SingleAssetExit[]",
              "name": "outcome",
              "type": "tuple[]"
            },
            {
              "internalType": "bytes",
              "name": "appData",
              "type": "bytes"
            },
            {
              "internalType": "uint48",
              "name": "turnNum",
              "type": "uint48"
            },
            {
              "internalType": "bool",
              "name": "isFinal",
              "type": "bool"
            }
          ],
          "internalType": "struct IForceMoveApp.VariablePart[]",
          "name": "variableParts",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "internalType": "uint8",
              "name": "v",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "r",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "s",
              "type": "bytes32"
            }
          ],
          "internalType": "struct IForceMove.Signature[]",
          "name": "sigs",
          "type": "tuple[]"
        },
        {
          "internalType": "uint8[]",
          "name": "whoSignedWhat",
          "type": "uint8[]"
        },
        {
          "components": [
            {
              "internalType": "uint8",
              "name": "v",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "r",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "s",
              "type": "bytes32"
            }
          ],
          "internalType": "struct IForceMove.Signature",
          "name": "challengerSig",
          "type": "tuple"
        }
      ],
      "name": "challenge",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "chainId",
              "type": "uint256"
            },
            {
              "internalType": "address[]",
              "name": "participants",
              "type": "address[]"
            },
            {
              "internalType": "uint48",
              "name": "channelNonce",
              "type": "uint48"
            },
            {
              "internalType": "address",
              "name": "appDefinition",
              "type": "address"
            },
            {
              "internalType": "uint48",
              "name": "challengeDuration",
              "type": "uint48"
            }
          ],
          "internalType": "struct IForceMove.FixedPart",
          "name": "fixedPart",
          "type": "tuple"
        },
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "asset",
                  "type": "address"
                },
                {
                  "internalType": "bytes",
                  "name": "metadata",
                  "type": "bytes"
                },
                {
                  "components": [
                    {
                      "internalType": "bytes32",
                      "name": "destination",
                      "type": "bytes32"
                    },
                    {
                      "internalType": "uint256",
                      "name": "amount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint8",
                      "name": "allocationType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "bytes",
                      "name": "metadata",
                      "type": "bytes"
                    }
                  ],
                  "internalType": "struct ExitFormat.Allocation[]",
                  "name": "allocations",
                  "type": "tuple[]"
                }
              ],
              "internalType": "struct ExitFormat.SingleAssetExit[]",
              "name": "outcome",
              "type": "tuple[]"
            },
            {
              "internalType": "bytes",
              "name": "appData",
              "type": "bytes"
            },
            {
              "internalType": "uint48",
              "name": "turnNum",
              "type": "uint48"
            },
            {
              "internalType": "bool",
              "name": "isFinal",
              "type": "bool"
            }
          ],
          "internalType": "struct IForceMoveApp.VariablePart[]",
          "name": "variableParts",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "internalType": "uint8",
              "name": "v",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "r",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "s",
              "type": "bytes32"
            }
          ],
          "internalType": "struct IForceMove.Signature[]",
          "name": "sigs",
          "type": "tuple[]"
        },
        {
          "internalType": "uint8[]",
          "name": "whoSignedWhat",
          "type": "uint8[]"
        }
      ],
      "name": "checkpoint",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "initialHoldings",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "destination",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            },
            {
              "internalType": "uint8",
              "name": "allocationType",
              "type": "uint8"
            },
            {
              "internalType": "bytes",
              "name": "metadata",
              "type": "bytes"
            }
          ],
          "internalType": "struct ExitFormat.Allocation[]",
          "name": "allocations",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256[]",
          "name": "indices",
          "type": "uint256[]"
        }
      ],
      "name": "compute_transfer_effects_and_interactions",
      "outputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "destination",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            },
            {
              "internalType": "uint8",
              "name": "allocationType",
              "type": "uint8"
            },
            {
              "internalType": "bytes",
              "name": "metadata",
              "type": "bytes"
            }
          ],
          "internalType": "struct ExitFormat.Allocation[]",
          "name": "newAllocations",
          "type": "tuple[]"
        },
        {
          "internalType": "bool",
          "name": "allocatesOnlyZeros",
          "type": "bool"
        },
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "destination",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            },
            {
              "internalType": "uint8",
              "name": "allocationType",
              "type": "uint8"
            },
            {
              "internalType": "bytes",
              "name": "metadata",
              "type": "bytes"
            }
          ],
          "internalType": "struct ExitFormat.Allocation[]",
          "name": "exitAllocations",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256",
          "name": "totalPayouts",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "chainId",
              "type": "uint256"
            },
            {
              "internalType": "address[]",
              "name": "participants",
              "type": "address[]"
            },
            {
              "internalType": "uint48",
              "name": "channelNonce",
              "type": "uint48"
            },
            {
              "internalType": "address",
              "name": "appDefinition",
              "type": "address"
            },
            {
              "internalType": "uint48",
              "name": "challengeDuration",
              "type": "uint48"
            }
          ],
          "internalType": "struct IForceMove.FixedPart",
          "name": "fixedPart",
          "type": "tuple"
        },
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "asset",
                  "type": "address"
                },
                {
                  "internalType": "bytes",
                  "name": "metadata",
                  "type": "bytes"
                },
                {
                  "components": [
                    {
                      "internalType": "bytes32",
                      "name": "destination",
                      "type": "bytes32"
                    },
                    {
                      "internalType": "uint256",
                      "name": "amount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint8",
                      "name": "allocationType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "bytes",
                      "name": "metadata",
                      "type": "bytes"
                    }
                  ],
                  "internalType": "struct ExitFormat.Allocation[]",
                  "name": "allocations",
                  "type": "tuple[]"
                }
              ],
              "internalType": "struct ExitFormat.SingleAssetExit[]",
              "name": "outcome",
              "type": "tuple[]"
            },
            {
              "internalType": "bytes",
              "name": "appData",
              "type": "bytes"
            },
            {
              "internalType": "uint48",
              "name": "turnNum",
              "type": "uint48"
            },
            {
              "internalType": "bool",
              "name": "isFinal",
              "type": "bool"
            }
          ],
          "internalType": "struct IForceMoveApp.VariablePart",
          "name": "latestVariablePart",
          "type": "tuple"
        },
        {
          "internalType": "uint8",
          "name": "numStates",
          "type": "uint8"
        },
        {
          "internalType": "uint8[]",
          "name": "whoSignedWhat",
          "type": "uint8[]"
        },
        {
          "components": [
            {
              "internalType": "uint8",
              "name": "v",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "r",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "s",
              "type": "bytes32"
            }
          ],
          "internalType": "struct IForceMove.Signature[]",
          "name": "sigs",
          "type": "tuple[]"
        }
      ],
      "name": "conclude",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "chainId",
              "type": "uint256"
            },
            {
              "internalType": "address[]",
              "name": "participants",
              "type": "address[]"
            },
            {
              "internalType": "uint48",
              "name": "channelNonce",
              "type": "uint48"
            },
            {
              "internalType": "address",
              "name": "appDefinition",
              "type": "address"
            },
            {
              "internalType": "uint48",
              "name": "challengeDuration",
              "type": "uint48"
            }
          ],
          "internalType": "struct IForceMove.FixedPart",
          "name": "fixedPart",
          "type": "tuple"
        },
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "asset",
                  "type": "address"
                },
                {
                  "internalType": "bytes",
                  "name": "metadata",
                  "type": "bytes"
                },
                {
                  "components": [
                    {
                      "internalType": "bytes32",
                      "name": "destination",
                      "type": "bytes32"
                    },
                    {
                      "internalType": "uint256",
                      "name": "amount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint8",
                      "name": "allocationType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "bytes",
                      "name": "metadata",
                      "type": "bytes"
                    }
                  ],
                  "internalType": "struct ExitFormat.Allocation[]",
                  "name": "allocations",
                  "type": "tuple[]"
                }
              ],
              "internalType": "struct ExitFormat.SingleAssetExit[]",
              "name": "outcome",
              "type": "tuple[]"
            },
            {
              "internalType": "bytes",
              "name": "appData",
              "type": "bytes"
            },
            {
              "internalType": "uint48",
              "name": "turnNum",
              "type": "uint48"
            },
            {
              "internalType": "bool",
              "name": "isFinal",
              "type": "bool"
            }
          ],
          "internalType": "struct IForceMoveApp.VariablePart",
          "name": "latestVariablePart",
          "type": "tuple"
        },
        {
          "internalType": "uint8",
          "name": "numStates",
          "type": "uint8"
        },
        {
          "internalType": "uint8[]",
          "name": "whoSignedWhat",
          "type": "uint8[]"
        },
        {
          "components": [
            {
              "internalType": "uint8",
              "name": "v",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "r",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "s",
              "type": "bytes32"
            }
          ],
          "internalType": "struct IForceMove.Signature[]",
          "name": "sigs",
          "type": "tuple[]"
        }
      ],
      "name": "concludeAndTransferAllAssets",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "asset",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "channelId",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "expectedHeld",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "deposit",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getChainID",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "holdings",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "numParticipants",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "numStates",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "numSigs",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "numWhoSignedWhats",
          "type": "uint256"
        }
      ],
      "name": "requireValidInput",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "chainId",
              "type": "uint256"
            },
            {
              "internalType": "address[]",
              "name": "participants",
              "type": "address[]"
            },
            {
              "internalType": "uint48",
              "name": "channelNonce",
              "type": "uint48"
            },
            {
              "internalType": "address",
              "name": "appDefinition",
              "type": "address"
            },
            {
              "internalType": "uint48",
              "name": "challengeDuration",
              "type": "uint48"
            }
          ],
          "internalType": "struct IForceMove.FixedPart",
          "name": "fixedPart",
          "type": "tuple"
        },
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "asset",
                  "type": "address"
                },
                {
                  "internalType": "bytes",
                  "name": "metadata",
                  "type": "bytes"
                },
                {
                  "components": [
                    {
                      "internalType": "bytes32",
                      "name": "destination",
                      "type": "bytes32"
                    },
                    {
                      "internalType": "uint256",
                      "name": "amount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint8",
                      "name": "allocationType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "bytes",
                      "name": "metadata",
                      "type": "bytes"
                    }
                  ],
                  "internalType": "struct ExitFormat.Allocation[]",
                  "name": "allocations",
                  "type": "tuple[]"
                }
              ],
              "internalType": "struct ExitFormat.SingleAssetExit[]",
              "name": "outcome",
              "type": "tuple[]"
            },
            {
              "internalType": "bytes",
              "name": "appData",
              "type": "bytes"
            },
            {
              "internalType": "uint48",
              "name": "turnNum",
              "type": "uint48"
            },
            {
              "internalType": "bool",
              "name": "isFinal",
              "type": "bool"
            }
          ],
          "internalType": "struct IForceMoveApp.VariablePart[2]",
          "name": "variablePartAB",
          "type": "tuple[2]"
        },
        {
          "components": [
            {
              "internalType": "uint8",
              "name": "v",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "r",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "s",
              "type": "bytes32"
            }
          ],
          "internalType": "struct IForceMove.Signature",
          "name": "sig",
          "type": "tuple"
        }
      ],
      "name": "respond",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "statusOf",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "assetIndex",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "fromChannelId",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "outcomeBytes",
          "type": "bytes"
        },
        {
          "internalType": "bytes32",
          "name": "stateHash",
          "type": "bytes32"
        },
        {
          "internalType": "uint256[]",
          "name": "indices",
          "type": "uint256[]"
        }
      ],
      "name": "transfer",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "channelId",
          "type": "bytes32"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "asset",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "metadata",
              "type": "bytes"
            },
            {
              "components": [
                {
                  "internalType": "bytes32",
                  "name": "destination",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "internalType": "uint8",
                  "name": "allocationType",
                  "type": "uint8"
                },
                {
                  "internalType": "bytes",
                  "name": "metadata",
                  "type": "bytes"
                }
              ],
              "internalType": "struct ExitFormat.Allocation[]",
              "name": "allocations",
              "type": "tuple[]"
            }
          ],
          "internalType": "struct ExitFormat.SingleAssetExit[]",
          "name": "outcome",
          "type": "tuple[]"
        },
        {
          "internalType": "bytes32",
          "name": "stateHash",
          "type": "bytes32"
        }
      ],
      "name": "transferAllAssets",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "channelId",
          "type": "bytes32"
        }
      ],
      "name": "unpackStatus",
      "outputs": [
        {
          "internalType": "uint48",
          "name": "turnNumRecord",
          "type": "uint48"
        },
        {
          "internalType": "uint48",
          "name": "finalizesAt",
          "type": "uint48"
        },
        {
          "internalType": "uint160",
          "name": "fingerprint",
          "type": "uint160"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "nParticipants",
          "type": "uint256"
        },
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "asset",
                  "type": "address"
                },
                {
                  "internalType": "bytes",
                  "name": "metadata",
                  "type": "bytes"
                },
                {
                  "components": [
                    {
                      "internalType": "bytes32",
                      "name": "destination",
                      "type": "bytes32"
                    },
                    {
                      "internalType": "uint256",
                      "name": "amount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint8",
                      "name": "allocationType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "bytes",
                      "name": "metadata",
                      "type": "bytes"
                    }
                  ],
                  "internalType": "struct ExitFormat.Allocation[]",
                  "name": "allocations",
                  "type": "tuple[]"
                }
              ],
              "internalType": "struct ExitFormat.SingleAssetExit[]",
              "name": "outcome",
              "type": "tuple[]"
            },
            {
              "internalType": "bytes",
              "name": "appData",
              "type": "bytes"
            },
            {
              "internalType": "uint48",
              "name": "turnNum",
              "type": "uint48"
            },
            {
              "internalType": "bool",
              "name": "isFinal",
              "type": "bool"
            }
          ],
          "internalType": "struct IForceMoveApp.VariablePart[2]",
          "name": "ab",
          "type": "tuple[2]"
        },
        {
          "internalType": "address",
          "name": "appDefinition",
          "type": "address"
        }
      ],
      "name": "validTransition",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0xdff99399070c3ea452ed8d17e0145630070d104c672050b60edcfb2bdd94b476",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0x5FbDB2315678afecb367f032d93F642f64180aa3",
    "transactionIndex": 0,
    "gasUsed": "4010006",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xa4757496064462e203e85ddd0d00ebf6aafad50c4b0f67b1b1051dc919d40d13",
    "transactionHash": "0xdff99399070c3ea452ed8d17e0145630070d104c672050b60edcfb2bdd94b476",
    "logs": [],
    "blockNumber": 1,
    "cumulativeGasUsed": "4010006",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "c2515da85d5a797d96ca5d49a9532dc5",
  "metadata": "{\"compiler\":{\"version\":\"0.7.6+commit.7338295f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"channelId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"initialHoldings\",\"type\":\"uint256\"}],\"name\":\"AllocationUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"channelId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint48\",\"name\":\"newTurnNumRecord\",\"type\":\"uint48\"}],\"name\":\"ChallengeCleared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"channelId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint48\",\"name\":\"turnNumRecord\",\"type\":\"uint48\"},{\"indexed\":false,\"internalType\":\"uint48\",\"name\":\"finalizesAt\",\"type\":\"uint48\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isFinal\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"participants\",\"type\":\"address[]\"},{\"internalType\":\"uint48\",\"name\":\"channelNonce\",\"type\":\"uint48\"},{\"internalType\":\"address\",\"name\":\"appDefinition\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"challengeDuration\",\"type\":\"uint48\"}],\"indexed\":false,\"internalType\":\"struct IForceMove.FixedPart\",\"name\":\"fixedPart\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"destination\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"allocationType\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"internalType\":\"struct ExitFormat.Allocation[]\",\"name\":\"allocations\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ExitFormat.SingleAssetExit[]\",\"name\":\"outcome\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"appData\",\"type\":\"bytes\"},{\"internalType\":\"uint48\",\"name\":\"turnNum\",\"type\":\"uint48\"},{\"internalType\":\"bool\",\"name\":\"isFinal\",\"type\":\"bool\"}],\"indexed\":false,\"internalType\":\"struct IForceMoveApp.VariablePart[]\",\"name\":\"variableParts\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"indexed\":false,\"internalType\":\"struct IForceMove.Signature[]\",\"name\":\"sigs\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"uint8[]\",\"name\":\"whoSignedWhat\",\"type\":\"uint8[]\"}],\"name\":\"ChallengeRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"channelId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint48\",\"name\":\"finalizesAt\",\"type\":\"uint48\"}],\"name\":\"Concluded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"destination\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountDeposited\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destinationHoldings\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"participants\",\"type\":\"address[]\"},{\"internalType\":\"uint48\",\"name\":\"channelNonce\",\"type\":\"uint48\"},{\"internalType\":\"address\",\"name\":\"appDefinition\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"challengeDuration\",\"type\":\"uint48\"}],\"internalType\":\"struct IForceMove.FixedPart\",\"name\":\"fixedPart\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"destination\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"allocationType\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"internalType\":\"struct ExitFormat.Allocation[]\",\"name\":\"allocations\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ExitFormat.SingleAssetExit[]\",\"name\":\"outcome\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"appData\",\"type\":\"bytes\"},{\"internalType\":\"uint48\",\"name\":\"turnNum\",\"type\":\"uint48\"},{\"internalType\":\"bool\",\"name\":\"isFinal\",\"type\":\"bool\"}],\"internalType\":\"struct IForceMoveApp.VariablePart[]\",\"name\":\"variableParts\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct IForceMove.Signature[]\",\"name\":\"sigs\",\"type\":\"tuple[]\"},{\"internalType\":\"uint8[]\",\"name\":\"whoSignedWhat\",\"type\":\"uint8[]\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct IForceMove.Signature\",\"name\":\"challengerSig\",\"type\":\"tuple\"}],\"name\":\"challenge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"participants\",\"type\":\"address[]\"},{\"internalType\":\"uint48\",\"name\":\"channelNonce\",\"type\":\"uint48\"},{\"internalType\":\"address\",\"name\":\"appDefinition\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"challengeDuration\",\"type\":\"uint48\"}],\"internalType\":\"struct IForceMove.FixedPart\",\"name\":\"fixedPart\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"destination\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"allocationType\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"internalType\":\"struct ExitFormat.Allocation[]\",\"name\":\"allocations\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ExitFormat.SingleAssetExit[]\",\"name\":\"outcome\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"appData\",\"type\":\"bytes\"},{\"internalType\":\"uint48\",\"name\":\"turnNum\",\"type\":\"uint48\"},{\"internalType\":\"bool\",\"name\":\"isFinal\",\"type\":\"bool\"}],\"internalType\":\"struct IForceMoveApp.VariablePart[]\",\"name\":\"variableParts\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct IForceMove.Signature[]\",\"name\":\"sigs\",\"type\":\"tuple[]\"},{\"internalType\":\"uint8[]\",\"name\":\"whoSignedWhat\",\"type\":\"uint8[]\"}],\"name\":\"checkpoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"initialHoldings\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"destination\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"allocationType\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"internalType\":\"struct ExitFormat.Allocation[]\",\"name\":\"allocations\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256[]\",\"name\":\"indices\",\"type\":\"uint256[]\"}],\"name\":\"compute_transfer_effects_and_interactions\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"destination\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"allocationType\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"internalType\":\"struct ExitFormat.Allocation[]\",\"name\":\"newAllocations\",\"type\":\"tuple[]\"},{\"internalType\":\"bool\",\"name\":\"allocatesOnlyZeros\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"destination\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"allocationType\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"internalType\":\"struct ExitFormat.Allocation[]\",\"name\":\"exitAllocations\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"totalPayouts\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"participants\",\"type\":\"address[]\"},{\"internalType\":\"uint48\",\"name\":\"channelNonce\",\"type\":\"uint48\"},{\"internalType\":\"address\",\"name\":\"appDefinition\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"challengeDuration\",\"type\":\"uint48\"}],\"internalType\":\"struct IForceMove.FixedPart\",\"name\":\"fixedPart\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"destination\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"allocationType\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"internalType\":\"struct ExitFormat.Allocation[]\",\"name\":\"allocations\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ExitFormat.SingleAssetExit[]\",\"name\":\"outcome\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"appData\",\"type\":\"bytes\"},{\"internalType\":\"uint48\",\"name\":\"turnNum\",\"type\":\"uint48\"},{\"internalType\":\"bool\",\"name\":\"isFinal\",\"type\":\"bool\"}],\"internalType\":\"struct IForceMoveApp.VariablePart\",\"name\":\"latestVariablePart\",\"type\":\"tuple\"},{\"internalType\":\"uint8\",\"name\":\"numStates\",\"type\":\"uint8\"},{\"internalType\":\"uint8[]\",\"name\":\"whoSignedWhat\",\"type\":\"uint8[]\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct IForceMove.Signature[]\",\"name\":\"sigs\",\"type\":\"tuple[]\"}],\"name\":\"conclude\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"participants\",\"type\":\"address[]\"},{\"internalType\":\"uint48\",\"name\":\"channelNonce\",\"type\":\"uint48\"},{\"internalType\":\"address\",\"name\":\"appDefinition\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"challengeDuration\",\"type\":\"uint48\"}],\"internalType\":\"struct IForceMove.FixedPart\",\"name\":\"fixedPart\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"destination\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"allocationType\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"internalType\":\"struct ExitFormat.Allocation[]\",\"name\":\"allocations\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ExitFormat.SingleAssetExit[]\",\"name\":\"outcome\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"appData\",\"type\":\"bytes\"},{\"internalType\":\"uint48\",\"name\":\"turnNum\",\"type\":\"uint48\"},{\"internalType\":\"bool\",\"name\":\"isFinal\",\"type\":\"bool\"}],\"internalType\":\"struct IForceMoveApp.VariablePart\",\"name\":\"latestVariablePart\",\"type\":\"tuple\"},{\"internalType\":\"uint8\",\"name\":\"numStates\",\"type\":\"uint8\"},{\"internalType\":\"uint8[]\",\"name\":\"whoSignedWhat\",\"type\":\"uint8[]\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct IForceMove.Signature[]\",\"name\":\"sigs\",\"type\":\"tuple[]\"}],\"name\":\"concludeAndTransferAllAssets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"channelId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"expectedHeld\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"holdings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numParticipants\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numStates\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numSigs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numWhoSignedWhats\",\"type\":\"uint256\"}],\"name\":\"requireValidInput\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"participants\",\"type\":\"address[]\"},{\"internalType\":\"uint48\",\"name\":\"channelNonce\",\"type\":\"uint48\"},{\"internalType\":\"address\",\"name\":\"appDefinition\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"challengeDuration\",\"type\":\"uint48\"}],\"internalType\":\"struct IForceMove.FixedPart\",\"name\":\"fixedPart\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"destination\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"allocationType\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"internalType\":\"struct ExitFormat.Allocation[]\",\"name\":\"allocations\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ExitFormat.SingleAssetExit[]\",\"name\":\"outcome\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"appData\",\"type\":\"bytes\"},{\"internalType\":\"uint48\",\"name\":\"turnNum\",\"type\":\"uint48\"},{\"internalType\":\"bool\",\"name\":\"isFinal\",\"type\":\"bool\"}],\"internalType\":\"struct IForceMoveApp.VariablePart[2]\",\"name\":\"variablePartAB\",\"type\":\"tuple[2]\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct IForceMove.Signature\",\"name\":\"sig\",\"type\":\"tuple\"}],\"name\":\"respond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"statusOf\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"fromChannelId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"outcomeBytes\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"stateHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"indices\",\"type\":\"uint256[]\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"channelId\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"destination\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"allocationType\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"internalType\":\"struct ExitFormat.Allocation[]\",\"name\":\"allocations\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ExitFormat.SingleAssetExit[]\",\"name\":\"outcome\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes32\",\"name\":\"stateHash\",\"type\":\"bytes32\"}],\"name\":\"transferAllAssets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"channelId\",\"type\":\"bytes32\"}],\"name\":\"unpackStatus\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"turnNumRecord\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"finalizesAt\",\"type\":\"uint48\"},{\"internalType\":\"uint160\",\"name\":\"fingerprint\",\"type\":\"uint160\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nParticipants\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"destination\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"allocationType\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"internalType\":\"struct ExitFormat.Allocation[]\",\"name\":\"allocations\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ExitFormat.SingleAssetExit[]\",\"name\":\"outcome\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"appData\",\"type\":\"bytes\"},{\"internalType\":\"uint48\",\"name\":\"turnNum\",\"type\":\"uint48\"},{\"internalType\":\"bool\",\"name\":\"isFinal\",\"type\":\"bool\"}],\"internalType\":\"struct IForceMoveApp.VariablePart[2]\",\"name\":\"ab\",\"type\":\"tuple[2]\"},{\"internalType\":\"address\",\"name\":\"appDefinition\",\"type\":\"address\"}],\"name\":\"validTransition\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"The Adjudicator contract extends MultiAssetHolder and ForceMove\",\"kind\":\"dev\",\"methods\":{\"challenge((uint256,address[],uint48,address,uint48),((address,bytes,(bytes32,uint256,uint8,bytes)[])[],bytes,uint48,bool)[],(uint8,bytes32,bytes32)[],uint8[],(uint8,bytes32,bytes32))\":{\"details\":\"Registers a challenge against a state channel. A challenge will either prompt another participant into clearing the challenge (via one of the other methods), or cause the channel to finalize at a specific time.\",\"params\":{\"challengerSig\":\"The signature of a participant on the keccak256 of the abi.encode of (supportedStateHash, 'forceMove').\",\"fixedPart\":\"Data describing properties of the state channel that do not change with state updates.\",\"sigs\":\"An array of signatures that support the state with the `largestTurnNum`. There must be one for each participant, e.g.: [sig-from-p0, sig-from-p1, ...]\",\"variableParts\":\"An ordered array of structs, each decribing the properties of the state channel that may change with each state update. Length is from 1 to the number of participants (inclusive).\",\"whoSignedWhat\":\"An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\"}},\"checkpoint((uint256,address[],uint48,address,uint48),((address,bytes,(bytes32,uint256,uint8,bytes)[])[],bytes,uint48,bool)[],(uint8,bytes32,bytes32)[],uint8[])\":{\"details\":\"Overwrites the `turnNumRecord` stored against a channel by providing a state with higher turn number, supported by a signature from each participant.\",\"params\":{\"fixedPart\":\"Data describing properties of the state channel that do not change with state updates.\",\"sigs\":\"An array of signatures that support the state with the `largestTurnNum`: one for each participant, in participant order (e.g. [sig of participant[0], sig of participant[1], ...]).\",\"variableParts\":\"An ordered array of structs, each decribing the properties of the state channel that may change with each state update.\",\"whoSignedWhat\":\"An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\"}},\"conclude((uint256,address[],uint48,address,uint48),((address,bytes,(bytes32,uint256,uint8,bytes)[])[],bytes,uint48,bool),uint8,uint8[],(uint8,bytes32,bytes32)[])\":{\"details\":\"Finalizes a channel by providing a finalization proof. External wrapper for _conclude.\",\"params\":{\"fixedPart\":\"Data describing properties of the state channel that do not change with state updates.\",\"latestVariablePart\":\"Latest variable part in finalization proof. Must have the largest turnNum and the same appData and outcome as all other variable parts in finalization proof.\",\"numStates\":\"The number of states in the finalization proof.\",\"sigs\":\"An array of signatures that support the state with the `largestTurnNum`: one for each participant, in participant order (e.g. [sig of participant[0], sig of participant[1], ...]).\",\"whoSignedWhat\":\"An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\"}},\"concludeAndTransferAllAssets((uint256,address[],uint48,address,uint48),((address,bytes,(bytes32,uint256,uint8,bytes)[])[],bytes,uint48,bool),uint8,uint8[],(uint8,bytes32,bytes32)[])\":{\"details\":\"Finalizes a channel by providing a finalization proof, and liquidates all assets for the channel.\",\"params\":{\"fixedPart\":\"Data describing properties of the state channel that do not change with state updates.\",\"latestVariablePart\":\"Latest variable part in finalization proof. Must have the largest turnNum and the same appData and outcome as all other variable parts in finalization proof.\",\"numStates\":\"The number of states in the finalization proof.\",\"sigs\":\"Array of signatures, one for each participant, in participant order (e.g. [sig of participant[0], sig of participant[1], ...]).\",\"whoSignedWhat\":\"An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\"}},\"deposit(address,bytes32,uint256,uint256)\":{\"details\":\"Deposit ETH or erc20 tokens against a given channelId.\",\"params\":{\"amount\":\"The intended number of wei/tokens to be deposited.\",\"asset\":\"erc20 token address, or zero address to indicate ETH\",\"channelId\":\"ChannelId to be credited.\",\"expectedHeld\":\"The number of wei/tokens the depositor believes are _already_ escrowed against the channelId.\"}},\"requireValidInput(uint256,uint256,uint256,uint256)\":{\"details\":\"Validates input for several external methods.\",\"params\":{\"numParticipants\":\"Length of the participants array\",\"numSigs\":\"Number of signatures submitted\",\"numStates\":\"Number of states submitted\",\"numWhoSignedWhats\":\"whoSignedWhat.length\"}},\"respond((uint256,address[],uint48,address,uint48),((address,bytes,(bytes32,uint256,uint8,bytes)[])[],bytes,uint48,bool)[2],(uint8,bytes32,bytes32))\":{\"details\":\"Repsonds to an ongoing challenge registered against a state channel.\",\"params\":{\"fixedPart\":\"Data describing properties of the state channel that do not change with state updates.\",\"sig\":\"The responder's signature on the `responseStateHash`.\",\"variablePartAB\":\"An pair of structs, each decribing the properties of the state channel that may change with each state update (for the challenge state and for the response state).\"}},\"transfer(uint256,bytes32,bytes,bytes32,uint256[])\":{\"details\":\"Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries.\",\"params\":{\"assetIndex\":\"Will be used to slice the outcome into a single asset outcome.\",\"fromChannelId\":\"Unique identifier for state channel to transfer funds *from*.\",\"indices\":\"Array with each entry denoting the index of a destination to transfer funds to. An empty array indicates \\\"all\\\".\",\"outcomeBytes\":\"The encoded Outcome of this state channel\",\"stateHash\":\"The hash of the state stored when the channel finalized.\"}},\"transferAllAssets(bytes32,(address,bytes,(bytes32,uint256,uint8,bytes)[])[],bytes32)\":{\"details\":\"Liquidates all assets for the channel\",\"params\":{\"channelId\":\"Unique identifier for a state channel\",\"outcome\":\"An array of SingleAssetExit[] items.\",\"stateHash\":\"stored state hash for the channel\"}},\"unpackStatus(bytes32)\":{\"details\":\"Unpacks turnNumRecord, finalizesAt and fingerprint from the status of a particular channel.\",\"params\":{\"channelId\":\"Unique identifier for a state channel.\"},\"returns\":{\"finalizesAt\":\"The unix timestamp when `channelId` will finalize.\",\"fingerprint\":\"The last 160 bits of kecca256(stateHash, outcomeHash)\",\"turnNumRecord\":\"A turnNum that (the adjudicator knows) is supported by a signature from each participant.\"}},\"validTransition(uint256,((address,bytes,(bytes32,uint256,uint8,bytes)[])[],bytes,uint48,bool)[2],address)\":{\"details\":\"Check that the submitted pair of states form a valid transition (public wrapper for internal function _requireValidTransition)\",\"params\":{\"ab\":\"Variable parts of each of the pair of states\",\"appDefinition\":\"Address of deployed contract containing application-specific validTransition function.\",\"nParticipants\":\"Number of participants in the channel. transition\"},\"returns\":{\"_0\":\"true if the later state is a validTransition from its predecessor, reverts otherwise.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"challenge((uint256,address[],uint48,address,uint48),((address,bytes,(bytes32,uint256,uint8,bytes)[])[],bytes,uint48,bool)[],(uint8,bytes32,bytes32)[],uint8[],(uint8,bytes32,bytes32))\":{\"notice\":\"Registers a challenge against a state channel. A challenge will either prompt another participant into clearing the challenge (via one of the other methods), or cause the channel to finalize at a specific time.\"},\"checkpoint((uint256,address[],uint48,address,uint48),((address,bytes,(bytes32,uint256,uint8,bytes)[])[],bytes,uint48,bool)[],(uint8,bytes32,bytes32)[],uint8[])\":{\"notice\":\"Overwrites the `turnNumRecord` stored against a channel by providing a state with higher turn number, supported by a signature from each participant.\"},\"conclude((uint256,address[],uint48,address,uint48),((address,bytes,(bytes32,uint256,uint8,bytes)[])[],bytes,uint48,bool),uint8,uint8[],(uint8,bytes32,bytes32)[])\":{\"notice\":\"Finalizes a channel by providing a finalization proof. External wrapper for _conclude.\"},\"concludeAndTransferAllAssets((uint256,address[],uint48,address,uint48),((address,bytes,(bytes32,uint256,uint8,bytes)[])[],bytes,uint48,bool),uint8,uint8[],(uint8,bytes32,bytes32)[])\":{\"notice\":\"Finalizes a channel by providing a finalization proof, and liquidates all assets for the channel.\"},\"deposit(address,bytes32,uint256,uint256)\":{\"notice\":\"Deposit ETH or erc20 tokens against a given channelId.\"},\"holdings(address,bytes32)\":{\"notice\":\"holdings[asset][channelId] is the amount of asset held against channel channelId. 0 address implies ETH\"},\"requireValidInput(uint256,uint256,uint256,uint256)\":{\"notice\":\"Validates input for several external methods.\"},\"respond((uint256,address[],uint48,address,uint48),((address,bytes,(bytes32,uint256,uint8,bytes)[])[],bytes,uint48,bool)[2],(uint8,bytes32,bytes32))\":{\"notice\":\"Repsonds to an ongoing challenge registered against a state channel.\"},\"transfer(uint256,bytes32,bytes,bytes32,uint256[])\":{\"notice\":\"Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries.\"},\"transferAllAssets(bytes32,(address,bytes,(bytes32,uint256,uint8,bytes)[])[],bytes32)\":{\"notice\":\"Liquidates all assets for the channel\"},\"unpackStatus(bytes32)\":{\"notice\":\"Unpacks turnNumRecord, finalizesAt and fingerprint from the status of a particular channel.\"},\"validTransition(uint256,((address,bytes,(bytes32,uint256,uint8,bytes)[])[],bytes,uint48,bool)[2],address)\":{\"notice\":\"Check that the submitted pair of states form a valid transition (public wrapper for internal function _requireValidTransition)\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/StateChannel/Adjudicator.sol\":\"Adjudicator\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"details\":{\"constantOptimizer\":true,\"cse\":true,\"deduplicate\":true,\"jumpdestRemover\":true,\"orderLiterals\":true,\"peephole\":true,\"yul\":true,\"yulDetails\":{\"optimizerSteps\":\"dhfoDgvulfnTUtnIf\",\"stackAllocation\":true}},\"runs\":2000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0xcc78a17dd88fa5a2edc60c8489e2f405c0913b377216a5b26b35656b2d0dab52\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x5f02220344881ce43204ae4a6281145a67bc52c2bb1290a791857df3d19d78f5\",\"license\":\"MIT\"},\"@statechannels/exit-format/contracts/ExitFormat.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.0;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface ERC20Interface {\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n}\\n\\n// Ideally this would be imported from @connect/vector-withdraw-helpers\\n// And the interface would match this one (note WithdrawData calldata wd has become bytes calldata cD)\\ninterface WithdrawHelper {\\n    function execute(bytes calldata cD, uint256 actualAmount) external;\\n}\\n\\nlibrary ExitFormat {\\n    // An Exit is an array of SingleAssetExit (one for each asset)\\n    // Exit = SingleAssetExit[]\\n\\n    // A SingleAssetExit specifies\\n    // * an asset address (0 implies the native asset of the chain: on mainnet, this is ETH)\\n    // * custom metadata (optional field, can be zero bytes). This might specify how to transfer this particular asset (e.g. target an \\\"ERC20.transfer\\\"' method)\\n    // * an allocations array\\n    struct SingleAssetExit {\\n        address asset;\\n        bytes metadata;\\n        Allocation[] allocations;\\n    }\\n\\n    // allocations is an ordered array of Allocation.\\n    // The ordering is important, and may express e.g. a priority order for the exit\\n    // (which would make a material difference to the final state in the case of running out of gas or funds)\\n    // Allocations = Allocation[]\\n\\n    enum AllocationType {simple, withdrawHelper, guarantee}\\n\\n    // An Allocation specifies\\n    // * a destination, referring either to an ethereum address or an application-specific identifier\\n    // * an amount of asset\\n    // * an allocationType, which directs calling code on how to interpret the allocation\\n    // * custom metadata (optional field, can be zero bytes). This can be used flexibly by different protocols.\\n    struct Allocation {\\n        bytes32 destination;\\n        uint256 amount;\\n        uint8 allocationType;\\n        bytes metadata;\\n    }\\n\\n    /**\\n     * specifies the decoding format for metadata bytes fields\\n     * received with the WithdrawHelper flag\\n     */\\n    struct WithdrawHelperMetaData {\\n        address callTo;\\n        bytes callData;\\n    }\\n\\n    // We use underscore parentheses to denote an _encodedVariable_\\n    function encodeExit(SingleAssetExit[] memory exit)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        return abi.encode(exit);\\n    }\\n\\n    function decodeExit(bytes memory _exit_)\\n        internal\\n        pure\\n        returns (SingleAssetExit[] memory)\\n    {\\n        return abi.decode(_exit_, (SingleAssetExit[]));\\n    }\\n\\n    function encodeAllocation(Allocation memory allocation)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        return abi.encode(allocation);\\n    }\\n\\n    function decodeAllocation(bytes memory _allocation_)\\n        internal\\n        pure\\n        returns (Allocation memory)\\n    {\\n        return abi.decode(_allocation_, (Allocation));\\n    }\\n\\n    function exitsEqual(\\n        SingleAssetExit[] memory exitA,\\n        SingleAssetExit[] memory exitB\\n    ) internal pure returns (bool) {\\n        return _bytesEqual(encodeExit(exitA), encodeExit(exitB));\\n    }\\n\\n    /**\\n     * @notice Executes an exit by paying out assets and calling external contracts\\n     * @dev Executes an exit by paying out assets and calling external contracts\\n     * @param exit The exit to be paid out.\\n     */\\n    function executeExit(ExitFormat.SingleAssetExit[] memory exit) internal {\\n        for (uint256 assetIndex = 0; assetIndex < exit.length; assetIndex++) {\\n            executeSingleAssetExit(exit[assetIndex]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Executes a single asset exit by paying out the asset and calling external contracts\\n     * @dev Executes a single asset exit by paying out the asset and calling external contracts\\n     * @param singleAssetExit The single asset exit to be paid out.\\n     */\\n    function executeSingleAssetExit(\\n        ExitFormat.SingleAssetExit memory singleAssetExit\\n    ) internal {\\n        address asset = singleAssetExit.asset;\\n        for (uint256 j = 0; j < singleAssetExit.allocations.length; j++) {\\n            require(\\n                _isAddress(singleAssetExit.allocations[j].destination),\\n                \\\"Destination is not a zero-padded address\\\"\\n            );\\n            address payable destination =\\n                payable(\\n                    address(\\n                        uint160(\\n                            uint256(singleAssetExit.allocations[j].destination)\\n                        )\\n                    )\\n                );\\n            uint256 amount = singleAssetExit.allocations[j].amount;\\n            if (asset == address(0)) {\\n                (bool success, ) = destination.call{value: amount}(\\\"\\\"); //solhint-disable-line avoid-low-level-calls\\n                require(success, \\\"Could not transfer ETH\\\");\\n            } else {\\n                // TODO support other token types via the singleAssetExit.metadata field\\n                ERC20Interface(asset).transfer(destination, amount);\\n            }\\n            if (\\n                singleAssetExit.allocations[j].allocationType ==\\n                uint8(AllocationType.withdrawHelper)\\n            ) {\\n                WithdrawHelperMetaData memory wd =\\n                    _parseWithdrawHelper(\\n                        singleAssetExit.allocations[j].metadata\\n                    );\\n                WithdrawHelper(wd.callTo).execute(wd.callData, amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks whether given destination is a valid Ethereum address\\n     * @dev Checks whether given destination is a valid Ethereum address\\n     * @param destination the destination to be checked\\n     */\\n    function _isAddress(bytes32 destination) internal pure returns (bool) {\\n        return uint96(bytes12(destination)) == 0;\\n    }\\n\\n    /**\\n     * @notice Returns a callTo address and callData from metadata bytes\\n     * @dev Returns a callTo address and callData from metadata bytes\\n     */\\n    function _parseWithdrawHelper(bytes memory metadata)\\n        internal\\n        pure\\n        returns (WithdrawHelperMetaData memory)\\n    {\\n        return abi.decode(metadata, (WithdrawHelperMetaData));\\n    }\\n\\n    /**\\n     * @notice Check for equality of two byte strings\\n     * @dev Check for equality of two byte strings\\n     * @param _preBytes One bytes string\\n     * @param _postBytes The other bytes string\\n     * @return true if the bytes are identical, false otherwise.\\n     */\\n    function _bytesEqual(bytes memory _preBytes, bytes memory _postBytes)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        // copied from https://www.npmjs.com/package/solidity-bytes-utils/v/0.1.1\\n        bool success = true;\\n\\n        /* solhint-disable no-inline-assembly */\\n        assembly {\\n            let length := mload(_preBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(length, mload(_postBytes))\\n                case 1 {\\n                    // cb is a circuit breaker in the for loop since there's\\n                    //  no said feature for inline assembly loops\\n                    // cb = 1 - don't breaker\\n                    // cb = 0 - break\\n                    let cb := 1\\n\\n                    let mc := add(_preBytes, 0x20)\\n                    let end := add(mc, length)\\n\\n                    for {\\n                        let cc := add(_postBytes, 0x20)\\n                        // the next line is the loop condition:\\n                        // while(uint256(mc < end) + cb == 2)\\n                    } eq(add(lt(mc, end), cb), 2) {\\n                        mc := add(mc, 0x20)\\n                        cc := add(cc, 0x20)\\n                    } {\\n                        // if any of these checks fails then arrays are not equal\\n                        if iszero(eq(mload(mc), mload(cc))) {\\n                            // unsuccess:\\n                            success := 0\\n                            cb := 0\\n                        }\\n                    }\\n                }\\n                default {\\n                    // unsuccess:\\n                    success := 0\\n                }\\n        }\\n        /* solhint-disable no-inline-assembly */\\n\\n        return success;\\n    }\\n}\\n\",\"keccak256\":\"0xb2d09e91c8f0496adba9701a81c900b25b78766a7a6ef23df4acb2f79de86e2e\",\"license\":\"MIT\"},\"contracts/StateChannel/Adjudicator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport './ForceMove.sol';\\nimport {ExitFormat as Outcome} from '@statechannels/exit-format/contracts/ExitFormat.sol';\\nimport './MultiAssetHolder.sol';\\n\\n/**\\n * @dev The Adjudicator contract extends MultiAssetHolder and ForceMove\\n */\\ncontract Adjudicator is ForceMove, MultiAssetHolder {\\n    /**\\n     * @notice Finalizes a channel by providing a finalization proof, and liquidates all assets for the channel.\\n     * @dev Finalizes a channel by providing a finalization proof, and liquidates all assets for the channel.\\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\\n     * @param latestVariablePart Latest variable part in finalization proof. Must have the largest turnNum and the same appData and outcome as all other variable parts in finalization proof.\\n     * @param numStates The number of states in the finalization proof.\\n     * @param whoSignedWhat An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\\n     * @param sigs Array of signatures, one for each participant, in participant order (e.g. [sig of participant[0], sig of participant[1], ...]).\\n     */\\n    function concludeAndTransferAllAssets(\\n        FixedPart memory fixedPart,\\n        IForceMoveApp.VariablePart memory latestVariablePart,\\n        uint8 numStates,\\n        uint8[] memory whoSignedWhat,\\n        Signature[] memory sigs\\n    ) public {\\n        bytes32 channelId = _conclude(\\n            fixedPart,\\n            latestVariablePart,\\n            numStates,\\n            whoSignedWhat,\\n            sigs\\n        );\\n\\n        transferAllAssets(channelId, latestVariablePart.outcome, bytes32(0));\\n    }\\n\\n    /**\\n     * @notice Liquidates all assets for the channel\\n     * @dev Liquidates all assets for the channel\\n     * @param channelId Unique identifier for a state channel\\n     * @param outcome An array of SingleAssetExit[] items.\\n     * @param stateHash stored state hash for the channel\\n     */\\n    function transferAllAssets(\\n        bytes32 channelId,\\n        Outcome.SingleAssetExit[] memory outcome,\\n        bytes32 stateHash\\n    ) public {\\n        // checks\\n        _requireChannelFinalized(channelId);\\n        _requireMatchingFingerprint(stateHash, _hashOutcome(outcome), channelId);\\n\\n        // computation\\n        bool allocatesOnlyZerosForAllAssets = true;\\n        Outcome.SingleAssetExit[] memory exit = new Outcome.SingleAssetExit[](outcome.length);\\n        uint256[] memory initialHoldings = new uint256[](outcome.length);\\n        uint256[] memory totalPayouts = new uint256[](outcome.length);\\n        for (uint256 assetIndex = 0; assetIndex < outcome.length; assetIndex++) {\\n            Outcome.SingleAssetExit memory assetOutcome = outcome[assetIndex];\\n            Outcome.Allocation[] memory allocations = assetOutcome.allocations;\\n            address asset = outcome[assetIndex].asset;\\n            initialHoldings[assetIndex] = holdings[asset][channelId];\\n            (\\n                Outcome.Allocation[] memory newAllocations,\\n                bool allocatesOnlyZeros,\\n                Outcome.Allocation[] memory exitAllocations,\\n                uint256 totalPayoutsForAsset\\n            ) = compute_transfer_effects_and_interactions(\\n                    initialHoldings[assetIndex],\\n                    allocations,\\n                    new uint256[](0)\\n                );\\n            if (!allocatesOnlyZeros) allocatesOnlyZerosForAllAssets = false;\\n            totalPayouts[assetIndex] = totalPayoutsForAsset;\\n            outcome[assetIndex].allocations = newAllocations;\\n            exit[assetIndex] = Outcome.SingleAssetExit(\\n                asset,\\n                assetOutcome.metadata,\\n                exitAllocations\\n            );\\n        }\\n\\n        // effects\\n        for (uint256 assetIndex = 0; assetIndex < outcome.length; assetIndex++) {\\n            address asset = outcome[assetIndex].asset;\\n            holdings[asset][channelId] -= totalPayouts[assetIndex];\\n            emit AllocationUpdated(channelId, assetIndex, initialHoldings[assetIndex]);\\n        }\\n\\n        if (allocatesOnlyZerosForAllAssets) {\\n            delete statusOf[channelId];\\n        } else {\\n            _updateFingerprint(channelId, stateHash, _hashOutcome(outcome));\\n        }\\n\\n        // interactions\\n        _executeExit(exit);\\n    }\\n\\n    /**\\n    * @notice Check that the submitted pair of states form a valid transition (public wrapper for internal function _requireValidTransition)\\n    * @dev Check that the submitted pair of states form a valid transition (public wrapper for internal function _requireValidTransition)\\n    * @param nParticipants Number of participants in the channel.\\n    transition\\n    * @param ab Variable parts of each of the pair of states\\n    * @param appDefinition Address of deployed contract containing application-specific validTransition function.\\n    * @return true if the later state is a validTransition from its predecessor, reverts otherwise.\\n    */\\n    function validTransition(\\n        uint256 nParticipants,\\n        IForceMoveApp.VariablePart[2] memory ab, // [a,b]\\n        address appDefinition\\n    ) public pure returns (bool) {\\n        return _requireValidTransition(nParticipants, ab, appDefinition);\\n    }\\n\\n    /**\\n     * @notice Executes an exit by paying out assets and calling external contracts\\n     * @dev Executes an exit by paying out assets and calling external contracts\\n     * @param exit The exit to be paid out.\\n     */\\n    function _executeExit(Outcome.SingleAssetExit[] memory exit) internal {\\n        for (uint256 assetIndex = 0; assetIndex < exit.length; assetIndex++) {\\n            _executeSingleAssetExit(exit[assetIndex]);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xfc7dee639d98bf5c19fb7567723c769ab77dfcc82b69e1434fae9d4fd255f333\",\"license\":\"MIT\"},\"contracts/StateChannel/ForceMove.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport {ExitFormat as Outcome} from '@statechannels/exit-format/contracts/ExitFormat.sol';\\nimport './interfaces/IForceMove.sol';\\nimport './interfaces/IForceMoveApp.sol';\\nimport './StatusManager.sol';\\n\\n/**\\n * @dev An implementation of ForceMove protocol, which allows state channels to be adjudicated and finalized.\\n */\\ncontract ForceMove is IForceMove, StatusManager {\\n    // *****************\\n    // External methods:\\n    // *****************\\n\\n    /**\\n     * @notice Unpacks turnNumRecord, finalizesAt and fingerprint from the status of a particular channel.\\n     * @dev Unpacks turnNumRecord, finalizesAt and fingerprint from the status of a particular channel.\\n     * @param channelId Unique identifier for a state channel.\\n     * @return turnNumRecord A turnNum that (the adjudicator knows) is supported by a signature from each participant.\\n     * @return finalizesAt The unix timestamp when `channelId` will finalize.\\n     * @return fingerprint The last 160 bits of kecca256(stateHash, outcomeHash)\\n     */\\n    function unpackStatus(bytes32 channelId)\\n        external\\n        view\\n        returns (\\n            uint48 turnNumRecord,\\n            uint48 finalizesAt,\\n            uint160 fingerprint\\n        )\\n    {\\n        (turnNumRecord, finalizesAt, fingerprint) = _unpackStatus(channelId);\\n    }\\n\\n    /**\\n     * @notice Registers a challenge against a state channel. A challenge will either prompt another participant into clearing the challenge (via one of the other methods), or cause the channel to finalize at a specific time.\\n     * @dev Registers a challenge against a state channel. A challenge will either prompt another participant into clearing the challenge (via one of the other methods), or cause the channel to finalize at a specific time.\\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\\n     * @param variableParts An ordered array of structs, each decribing the properties of the state channel that may change with each state update. Length is from 1 to the number of participants (inclusive).\\n     * @param sigs An array of signatures that support the state with the `largestTurnNum`. There must be one for each participant, e.g.: [sig-from-p0, sig-from-p1, ...]\\n     * @param whoSignedWhat An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\\n     * @param challengerSig The signature of a participant on the keccak256 of the abi.encode of (supportedStateHash, 'forceMove').\\n     */\\n    function challenge(\\n        FixedPart memory fixedPart,\\n        IForceMoveApp.VariablePart[] memory variableParts,\\n        Signature[] memory sigs,\\n        uint8[] memory whoSignedWhat,\\n        Signature memory challengerSig\\n    ) external override {\\n        // input type validation\\n        requireValidInput(\\n            fixedPart.participants.length,\\n            variableParts.length,\\n            sigs.length,\\n            whoSignedWhat.length\\n        );\\n\\n        bytes32 channelId = _getChannelId(fixedPart);\\n        uint48 largestTurnNum = _lastVariablePart(variableParts).turnNum;\\n\\n        if (_mode(channelId) == ChannelMode.Open) {\\n            _requireNonDecreasedTurnNumber(channelId, largestTurnNum);\\n        } else if (_mode(channelId) == ChannelMode.Challenge) {\\n            _requireIncreasedTurnNumber(channelId, largestTurnNum);\\n        } else {\\n            // This should revert.\\n            _requireChannelNotFinalized(channelId);\\n        }\\n        bytes32 supportedStateHash = _requireStateSupportedBy(\\n            variableParts,\\n            channelId,\\n            fixedPart,\\n            sigs,\\n            whoSignedWhat\\n        );\\n\\n        _requireChallengerIsParticipant(supportedStateHash, fixedPart.participants, challengerSig);\\n\\n        // effects\\n\\n        emit ChallengeRegistered(\\n            channelId,\\n            largestTurnNum,\\n            uint48(block.timestamp) + fixedPart.challengeDuration, //solhint-disable-line not-rely-on-time\\n            // This could overflow, so don't join a channel with a huge challengeDuration\\n            _lastVariablePart(variableParts).isFinal,\\n            fixedPart,\\n            variableParts,\\n            sigs,\\n            whoSignedWhat\\n        );\\n\\n        statusOf[channelId] = _generateStatus(\\n            ChannelData(\\n                largestTurnNum,\\n                uint48(block.timestamp) + fixedPart.challengeDuration, //solhint-disable-line not-rely-on-time\\n                supportedStateHash,\\n                _hashOutcome(_lastVariablePart(variableParts).outcome)\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice Repsonds to an ongoing challenge registered against a state channel.\\n     * @dev Repsonds to an ongoing challenge registered against a state channel.\\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\\n     * @param variablePartAB An pair of structs, each decribing the properties of the state channel that may change with each state update (for the challenge state and for the response state).\\n     * @param sig The responder's signature on the `responseStateHash`.\\n     */\\n    function respond(\\n        FixedPart memory fixedPart,\\n        IForceMoveApp.VariablePart[2] memory variablePartAB,\\n        // variablePartAB[0] = challengeVariablePart\\n        // variablePartAB[1] = responseVariablePart\\n        Signature memory sig\\n    ) external override {\\n        // No need to validate fixedPart.participants.length here, as that validation would have happened during challenge\\n\\n        bytes32 channelId = _getChannelId(fixedPart);\\n        (uint48 turnNumRecord, uint48 finalizesAt, ) = _unpackStatus(channelId);\\n\\n        bytes32 challengeStateHash = _hashState(\\n            channelId,\\n            variablePartAB[0].appData,\\n            variablePartAB[0].outcome,\\n            turnNumRecord,\\n            variablePartAB[0].isFinal\\n        );\\n\\n        bytes32 responseStateHash = _hashState(\\n            channelId,\\n            variablePartAB[1].appData,\\n            variablePartAB[1].outcome,\\n            turnNumRecord + 1,\\n            variablePartAB[1].isFinal\\n        );\\n\\n        // checks\\n\\n        _requireSpecificChallenge(\\n            ChannelData(\\n                turnNumRecord,\\n                finalizesAt,\\n                challengeStateHash,\\n                _hashOutcome(variablePartAB[0].outcome)\\n            ),\\n            channelId\\n        );\\n\\n        require(\\n            _recoverSigner(responseStateHash, sig) ==\\n                fixedPart.participants[(turnNumRecord + 1) % fixedPart.participants.length],\\n            'Signer not authorized mover'\\n        );\\n\\n        _requireValidTransition(\\n            fixedPart.participants.length,\\n            variablePartAB,\\n            fixedPart.appDefinition\\n        );\\n\\n        // effects\\n        _clearChallenge(channelId, turnNumRecord + 1);\\n    }\\n\\n    /**\\n     * @notice Overwrites the `turnNumRecord` stored against a channel by providing a state with higher turn number, supported by a signature from each participant.\\n     * @dev Overwrites the `turnNumRecord` stored against a channel by providing a state with higher turn number, supported by a signature from each participant.\\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\\n     * @param variableParts An ordered array of structs, each decribing the properties of the state channel that may change with each state update.\\n     * @param sigs An array of signatures that support the state with the `largestTurnNum`: one for each participant, in participant order (e.g. [sig of participant[0], sig of participant[1], ...]).\\n     * @param whoSignedWhat An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\\n     */\\n    function checkpoint(\\n        FixedPart memory fixedPart,\\n        IForceMoveApp.VariablePart[] memory variableParts,\\n        Signature[] memory sigs,\\n        uint8[] memory whoSignedWhat\\n    ) external override {\\n        // input type validation\\n        requireValidInput(\\n            fixedPart.participants.length,\\n            variableParts.length,\\n            sigs.length,\\n            whoSignedWhat.length\\n        );\\n\\n        bytes32 channelId = _getChannelId(fixedPart);\\n        uint48 largestTurnNum = _lastVariablePart(variableParts).turnNum;\\n\\n        // checks\\n        _requireChannelNotFinalized(channelId);\\n        _requireIncreasedTurnNumber(channelId, largestTurnNum);\\n        _requireStateSupportedBy(variableParts, channelId, fixedPart, sigs, whoSignedWhat);\\n\\n        // effects\\n        _clearChallenge(channelId, largestTurnNum);\\n    }\\n\\n    /**\\n     * @notice Finalizes a channel by providing a finalization proof. External wrapper for _conclude.\\n     * @dev Finalizes a channel by providing a finalization proof. External wrapper for _conclude.\\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\\n     * @param latestVariablePart Latest variable part in finalization proof. Must have the largest turnNum and the same appData and outcome as all other variable parts in finalization proof.\\n     * @param numStates The number of states in the finalization proof.\\n     * @param whoSignedWhat An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\\n     * @param sigs An array of signatures that support the state with the `largestTurnNum`: one for each participant, in participant order (e.g. [sig of participant[0], sig of participant[1], ...]).\\n     */\\n    function conclude(\\n        FixedPart memory fixedPart,\\n        IForceMoveApp.VariablePart memory latestVariablePart,\\n        uint8 numStates,\\n        uint8[] memory whoSignedWhat,\\n        Signature[] memory sigs\\n    ) external override {\\n        _conclude(fixedPart, latestVariablePart, numStates, whoSignedWhat, sigs);\\n    }\\n\\n    /**\\n     * @notice Finalizes a channel by providing a finalization proof. Internal method.\\n     * @dev Finalizes a channel by providing a finalization proof. Internal method.\\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\\n     * @param latestVariablePart Latest variable part in finalization proof. Must have the largest turnNum and the same appData and outcome as all other variable parts in finalization proof.\\n     * @param numStates The number of states in the finalization proof.\\n     * @param whoSignedWhat An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\\n     * @param sigs An array of signatures that support the state with the `largestTurnNum`:: one for each participant, in participant order (e.g. [sig of participant[0], sig of participant[1], ...]).\\n     */\\n    function _conclude(\\n        FixedPart memory fixedPart,\\n        IForceMoveApp.VariablePart memory latestVariablePart,\\n        uint8 numStates,\\n        uint8[] memory whoSignedWhat,\\n        Signature[] memory sigs\\n    ) internal returns (bytes32 channelId) {\\n        channelId = _getChannelId(fixedPart);\\n        _requireChannelNotFinalized(channelId);\\n\\n        // input type validation\\n        requireValidInput(\\n            fixedPart.participants.length,\\n            numStates,\\n            sigs.length,\\n            whoSignedWhat.length\\n        );\\n\\n        require(latestVariablePart.turnNum + 1 >= numStates, 'largestTurnNum too low');\\n        // ^^ SW-C101: prevent underflow\\n\\n        // By construction, the following states form a valid transition\\n        bytes32[] memory stateHashes = new bytes32[](numStates);\\n        for (uint48 i = 0; i < numStates; i++) {\\n            stateHashes[i] = _hashState(\\n                channelId,\\n                latestVariablePart.appData,\\n                latestVariablePart.outcome,\\n                latestVariablePart.turnNum + (i + 1) - numStates, // turnNum\\n                // ^^ SW-C101: It is not easy to use SafeMath here, since we are not using uint256s\\n                // Instead, we are protected by the require statement above\\n                true // isFinal\\n            );\\n        }\\n\\n        // checks\\n        require(\\n            _validSignatures(\\n                latestVariablePart.turnNum,\\n                fixedPart.participants,\\n                stateHashes,\\n                sigs,\\n                whoSignedWhat\\n            ),\\n            'Invalid signatures / !isFinal'\\n        );\\n\\n        // effects\\n        statusOf[channelId] = _generateStatus(\\n            ChannelData(\\n                0,\\n                uint48(block.timestamp), //solhint-disable-line not-rely-on-time\\n                bytes32(0),\\n                _hashOutcome(latestVariablePart.outcome)\\n            )\\n        );\\n        emit Concluded(channelId, uint48(block.timestamp)); //solhint-disable-line not-rely-on-time\\n    }\\n\\n    function getChainID() public pure returns (uint256) {\\n        uint256 id;\\n        /* solhint-disable no-inline-assembly */\\n        assembly {\\n            id := chainid()\\n        }\\n        /* solhint-disable no-inline-assembly */\\n        return id;\\n    }\\n\\n    /**\\n     * @notice Validates input for several external methods.\\n     * @dev Validates input for several external methods.\\n     * @param numParticipants Length of the participants array\\n     * @param numStates Number of states submitted\\n     * @param numSigs Number of signatures submitted\\n     * @param numWhoSignedWhats whoSignedWhat.length\\n     */\\n    function requireValidInput(\\n        uint256 numParticipants,\\n        uint256 numStates,\\n        uint256 numSigs,\\n        uint256 numWhoSignedWhats\\n    ) public pure returns (bool) {\\n        require((numParticipants >= numStates) && (numStates > 0), 'Insufficient or excess states');\\n        require(\\n            (numSigs == numParticipants) && (numWhoSignedWhats == numParticipants),\\n            'Bad |signatures|v|whoSignedWhat|'\\n        );\\n        require(numParticipants <= type(uint8).max, 'Too many participants!'); // type(uint8).max = 2**8 - 1 = 255\\n        // no more than 255 participants\\n        // max index for participants is 254\\n        return true;\\n    }\\n\\n    // *****************\\n    // Internal methods:\\n    // *****************\\n\\n    /**\\n     * @notice Checks that the challengerSignature was created by one of the supplied participants.\\n     * @dev Checks that the challengerSignature was created by one of the supplied participants.\\n     * @param supportedStateHash Forms part of the digest to be signed, along with the string 'forceMove'.\\n     * @param participants A list of addresses representing the participants of a channel.\\n     * @param challengerSignature The signature of a participant on the keccak256 of the abi.encode of (supportedStateHash, 'forceMove').\\n     */\\n    function _requireChallengerIsParticipant(\\n        bytes32 supportedStateHash,\\n        address[] memory participants,\\n        Signature memory challengerSignature\\n    ) internal pure {\\n        address challenger = _recoverSigner(\\n            keccak256(abi.encode(supportedStateHash, 'forceMove')),\\n            challengerSignature\\n        );\\n        require(_isAddressInArray(challenger, participants), 'Challenger is not a participant');\\n    }\\n\\n    /**\\n     * @notice Tests whether a given address is in a given array of addresses.\\n     * @dev Tests whether a given address is in a given array of addresses.\\n     * @param suspect A single address of interest.\\n     * @param addresses A line-up of possible perpetrators.\\n     * @return true if the address is in the array, false otherwise\\n     */\\n    function _isAddressInArray(address suspect, address[] memory addresses)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        for (uint256 i = 0; i < addresses.length; i++) {\\n            if (suspect == addresses[i]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * @notice Given an array of state hashes, checks the validity of the supplied signatures. Valid means there is a signature for each participant, either on the hash of the state for which they are a mover, or on the hash of a state that appears after that state in the array.\\n     * @dev Given an array of state hashes, checks the validity of the supplied signatures. Valid means there is a signature for each participant, either on the hash of the state for which they are a mover, or on the hash of a state that appears after that state in the array.\\n     * @param largestTurnNum The largest turn number of the submitted states; will overwrite the stored value of `turnNumRecord`.\\n     * @param participants A list of addresses representing the participants of a channel.\\n     * @param stateHashes Array of keccak256(State) submitted in support of a state,\\n     * @param sigs Array of Signatures, one for each participant, in participant order (e.g. [sig of participant[0], sig of participant[1], ...]).\\n     * @param whoSignedWhat participant[i] signed stateHashes[whoSignedWhat[i]]\\n     * @return true if the signatures are valid, false otherwise\\n     */\\n    function _validSignatures(\\n        uint48 largestTurnNum,\\n        address[] memory participants,\\n        bytes32[] memory stateHashes,\\n        Signature[] memory sigs,\\n        uint8[] memory whoSignedWhat // whoSignedWhat[i] is the index of the state in stateHashes that was signed by participants[i]\\n    ) internal pure returns (bool) {\\n        uint256 nParticipants = participants.length;\\n        uint256 nStates = stateHashes.length;\\n\\n        require(\\n            _acceptableWhoSignedWhat(whoSignedWhat, largestTurnNum, nParticipants, nStates),\\n            'Unacceptable whoSignedWhat array'\\n        );\\n        for (uint256 i = 0; i < nParticipants; i++) {\\n            address signer = _recoverSigner(stateHashes[whoSignedWhat[i]], sigs[i]);\\n            if (signer != participants[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Given a declaration of which state in the support proof was signed by which participant, check if this declaration is acceptable. Acceptable means there is a signature for each participant, either on the hash of the state for which they are a mover, or on the hash of a state that appears after that state in the array.\\n     * @dev Given a declaration of which state in the support proof was signed by which participant, check if this declaration is acceptable. Acceptable means there is a signature for each participant, either on the hash of the state for which they are a mover, or on the hash of a state that appears after that state in the array.\\n     * @param whoSignedWhat participant[i] signed stateHashes[whoSignedWhat[i]]\\n     * @param largestTurnNum Largest turnNum of the support proof\\n     * @param nParticipants Number of participants in the channel\\n     * @param nStates Number of states in the support proof\\n     * @return true if whoSignedWhat is acceptable, false otherwise\\n     */\\n    function _acceptableWhoSignedWhat(\\n        uint8[] memory whoSignedWhat,\\n        uint48 largestTurnNum,\\n        uint256 nParticipants,\\n        uint256 nStates\\n    ) internal pure returns (bool) {\\n        require(whoSignedWhat.length == nParticipants, '|whoSignedWhat|!=nParticipants');\\n        for (uint256 i = 0; i < nParticipants; i++) {\\n            uint256 offset = (nParticipants + largestTurnNum - i) % nParticipants;\\n            // offset is the difference between the index of participant[i] and the index of the participant who owns the largesTurnNum state\\n            // the additional nParticipants in the dividend ensures offset always positive\\n            if (whoSignedWhat[i] + offset + 1 < nStates) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Given a digest and ethereum digital signature, recover the signer\\n     * @dev Given a digest and digital signature, recover the signer\\n     * @param _d message digest\\n     * @param sig ethereum digital signature\\n     * @return signer\\n     */\\n    function _recoverSigner(bytes32 _d, Signature memory sig) internal pure returns (address) {\\n        bytes32 prefixedHash = keccak256(abi.encodePacked('\\\\x19Ethereum Signed Message:\\\\n32', _d));\\n        address a = ecrecover(prefixedHash, sig.v, sig.r, sig.s);\\n        require(a != address(0), 'Invalid signature');\\n        return (a);\\n    }\\n\\n    /**\\n     * @notice Check that the submitted data constitute a support proof.\\n     * @dev Check that the submitted data constitute a support proof.\\n     * @param variableParts Variable parts of the states in the support proof\\n     * @param channelId Unique identifier for a channel.\\n     * @param fixedPart Fixed Part of the states in the support proof\\n     * @param sigs A signature from each participant, in participant order (e.g. [sig of participant[0], sig of participant[1], ...]).\\n     * @param whoSignedWhat participant[i] signed stateHashes[whoSignedWhat[i]]\\n     * @return The hash of the latest state in the proof, if supported, else reverts.\\n     */\\n    function _requireStateSupportedBy(\\n        IForceMoveApp.VariablePart[] memory variableParts,\\n        bytes32 channelId,\\n        FixedPart memory fixedPart,\\n        Signature[] memory sigs,\\n        uint8[] memory whoSignedWhat\\n    ) internal pure returns (bytes32) {\\n        bytes32[] memory stateHashes = _requireValidTransitionChain(\\n            variableParts,\\n            channelId,\\n            fixedPart\\n        );\\n\\n        require(\\n            _validSignatures(\\n                _lastVariablePart(variableParts).turnNum,\\n                fixedPart.participants,\\n                stateHashes,\\n                sigs,\\n                whoSignedWhat\\n            ),\\n            'Invalid signatures'\\n        );\\n\\n        return stateHashes[stateHashes.length - 1];\\n    }\\n\\n    /**\\n     * @notice Check that the submitted states form a chain of valid transitions\\n     * @dev Check that the submitted states form a chain of valid transitions\\n     * @param variableParts Variable parts of the states in the support proof\\n     * @param channelId Unique identifier for a channel.\\n     * @param fixedPart Fixed Part of the states in the support proof\\n     * @return true if every state is a validTransition from its predecessor, false otherwise.\\n     */\\n    function _requireValidTransitionChain(\\n        // returns stateHashes array if valid\\n        // else, reverts\\n        IForceMoveApp.VariablePart[] memory variableParts,\\n        bytes32 channelId,\\n        FixedPart memory fixedPart\\n    ) internal pure returns (bytes32[] memory) {\\n        bytes32[] memory stateHashes = new bytes32[](variableParts.length);\\n\\n        for (uint48 i = 0; i < variableParts.length; i++) {\\n            stateHashes[i] = _hashState(\\n                channelId,\\n                variableParts[i].appData,\\n                variableParts[i].outcome,\\n                variableParts[i].turnNum,\\n                variableParts[i].isFinal\\n            );\\n            if (i < variableParts.length - 1) {\\n                _requireValidTransition(\\n                    fixedPart.participants.length,\\n                    [variableParts[i], variableParts[i + 1]],\\n                    fixedPart.appDefinition\\n                );\\n            }\\n        }\\n        return stateHashes;\\n    }\\n\\n    enum IsValidTransition {\\n        True,\\n        NeedToCheckApp\\n    }\\n\\n    /**\\n    * @notice Check that the submitted pair of states form a valid transition\\n    * @dev Check that the submitted pair of states form a valid transition\\n    * @param nParticipants Number of participants in the channel.\\n    transition\\n    * @param ab Variable parts of each of the pair of states\\n    * @return true if the later state is a validTransition from its predecessor, false otherwise.\\n    */\\n    function _requireValidProtocolTransition(\\n        uint256 nParticipants,\\n        IForceMoveApp.VariablePart[2] memory ab // [a,b]\\n    ) internal pure returns (IsValidTransition) {\\n        // a separate check on the signatures for the submitted states implies that the following fields are equal for a and b:\\n        // chainId, participants, channelNonce, appDefinition, challengeDuration\\n        // and that the b.turnNum = a.turnNum + 1\\n        if (ab[1].isFinal) {\\n            require(Outcome.exitsEqual(ab[1].outcome, ab[0].outcome), 'Outcome change verboten');\\n        } else {\\n            require(!ab[0].isFinal, 'isFinal retrograde');\\n            if (ab[1].turnNum < 2 * nParticipants) {\\n                require(\\n                    Outcome.exitsEqual(ab[1].outcome, ab[0].outcome),\\n                    'Outcome change forbidden'\\n                );\\n                require(_bytesEqual(ab[1].appData, ab[0].appData), 'appData change forbidden');\\n            } else {\\n                return IsValidTransition.NeedToCheckApp;\\n            }\\n        }\\n        return IsValidTransition.True;\\n    }\\n\\n    /**\\n    * @notice Check that the submitted pair of states form a valid transition\\n    * @dev Check that the submitted pair of states form a valid transition\\n    * @param nParticipants Number of participants in the channel.\\n    transition\\n    * @param ab Variable parts of each of the pair of states\\n    * @param appDefinition Address of deployed contract containing application-specific validTransition function.\\n    * @return true if the later state is a validTransition from its predecessor, false otherwise.\\n    */\\n    function _requireValidTransition(\\n        uint256 nParticipants,\\n        IForceMoveApp.VariablePart[2] memory ab, // [a,b]\\n        address appDefinition\\n    ) internal pure returns (bool) {\\n        IsValidTransition isValidProtocolTransition = _requireValidProtocolTransition(\\n            nParticipants,\\n            ab // [a,b]\\n        );\\n\\n        if (isValidProtocolTransition == IsValidTransition.NeedToCheckApp) {\\n            require(\\n                IForceMoveApp(appDefinition).validTransition(ab[0], ab[1], nParticipants),\\n                'Invalid ForceMoveApp Transition'\\n            );\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Check for equality of two byte strings\\n     * @dev Check for equality of two byte strings\\n     * @param _preBytes One bytes string\\n     * @param _postBytes The other bytes string\\n     * @return true if the bytes are identical, false otherwise.\\n     */\\n    function _bytesEqual(bytes memory _preBytes, bytes memory _postBytes)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        // copied from https://www.npmjs.com/package/solidity-bytes-utils/v/0.1.1\\n        bool success = true;\\n\\n        /* solhint-disable no-inline-assembly */\\n        assembly {\\n            let length := mload(_preBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(length, mload(_postBytes))\\n            case 1 {\\n                // cb is a circuit breaker in the for loop since there's\\n                //  no said feature for inline assembly loops\\n                // cb = 1 - don't breaker\\n                // cb = 0 - break\\n                let cb := 1\\n\\n                let mc := add(_preBytes, 0x20)\\n                let end := add(mc, length)\\n\\n                for {\\n                    let cc := add(_postBytes, 0x20)\\n                    // the next line is the loop condition:\\n                    // while(uint256(mc < end) + cb == 2)\\n                } eq(add(lt(mc, end), cb), 2) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    // if any of these checks fails then arrays are not equal\\n                    if iszero(eq(mload(mc), mload(cc))) {\\n                        // unsuccess:\\n                        success := 0\\n                        cb := 0\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n        /* solhint-disable no-inline-assembly */\\n\\n        return success;\\n    }\\n\\n    /**\\n     * @notice Clears a challenge by updating the turnNumRecord and resetting the remaining channel storage fields, and emits a ChallengeCleared event.\\n     * @dev Clears a challenge by updating the turnNumRecord and resetting the remaining channel storage fields, and emits a ChallengeCleared event.\\n     * @param channelId Unique identifier for a channel.\\n     * @param newTurnNumRecord New turnNumRecord to overwrite existing value\\n     */\\n    function _clearChallenge(bytes32 channelId, uint48 newTurnNumRecord) internal {\\n        statusOf[channelId] = _generateStatus(\\n            ChannelData(newTurnNumRecord, 0, bytes32(0), bytes32(0))\\n        );\\n        emit ChallengeCleared(channelId, newTurnNumRecord);\\n    }\\n\\n    /**\\n     * @notice Checks that the submitted turnNumRecord is strictly greater than the turnNumRecord stored on chain.\\n     * @dev Checks that the submitted turnNumRecord is strictly greater than the turnNumRecord stored on chain.\\n     * @param channelId Unique identifier for a channel.\\n     * @param newTurnNumRecord New turnNumRecord intended to overwrite existing value\\n     */\\n    function _requireIncreasedTurnNumber(bytes32 channelId, uint48 newTurnNumRecord) internal view {\\n        (uint48 turnNumRecord, , ) = _unpackStatus(channelId);\\n        require(newTurnNumRecord > turnNumRecord, 'turnNumRecord not increased.');\\n    }\\n\\n    /**\\n     * @notice Checks that the submitted turnNumRecord is greater than or equal to the turnNumRecord stored on chain.\\n     * @dev Checks that the submitted turnNumRecord is greater than or equal to the turnNumRecord stored on chain.\\n     * @param channelId Unique identifier for a channel.\\n     * @param newTurnNumRecord New turnNumRecord intended to overwrite existing value\\n     */\\n    function _requireNonDecreasedTurnNumber(bytes32 channelId, uint48 newTurnNumRecord)\\n        internal\\n        view\\n    {\\n        (uint48 turnNumRecord, , ) = _unpackStatus(channelId);\\n        require(newTurnNumRecord >= turnNumRecord, 'turnNumRecord decreased.');\\n    }\\n\\n    /**\\n     * @notice Checks that a given ChannelData struct matches the challenge stored on chain, and that the channel is in Challenge mode.\\n     * @dev Checks that a given ChannelData struct matches the challenge stored on chain, and that the channel is in Challenge mode.\\n     * @param data A given ChannelData data structure.\\n     * @param channelId Unique identifier for a channel.\\n     */\\n    function _requireSpecificChallenge(ChannelData memory data, bytes32 channelId) internal view {\\n        _requireMatchingStorage(data, channelId);\\n        _requireOngoingChallenge(channelId);\\n    }\\n\\n    /**\\n     * @notice Checks that a given channel is in the Challenge mode.\\n     * @dev Checks that a given channel is in the Challenge mode.\\n     * @param channelId Unique identifier for a channel.\\n     */\\n    function _requireOngoingChallenge(bytes32 channelId) internal view {\\n        require(_mode(channelId) == ChannelMode.Challenge, 'No ongoing challenge.');\\n    }\\n\\n    /**\\n     * @notice Checks that a given channel is NOT in the Finalized mode.\\n     * @dev Checks that a given channel is in the Challenge mode.\\n     * @param channelId Unique identifier for a channel.\\n     */\\n    function _requireChannelNotFinalized(bytes32 channelId) internal view {\\n        require(_mode(channelId) != ChannelMode.Finalized, 'Channel finalized.');\\n    }\\n\\n    /**\\n     * @notice Checks that a given channel is in the Open mode.\\n     * @dev Checks that a given channel is in the Challenge mode.\\n     * @param channelId Unique identifier for a channel.\\n     */\\n    function _requireChannelOpen(bytes32 channelId) internal view {\\n        require(_mode(channelId) == ChannelMode.Open, 'Channel not open.');\\n    }\\n\\n    /**\\n     * @notice Checks that a given ChannelData struct matches the challenge stored on chain.\\n     * @dev Checks that a given ChannelData struct matches the challenge stored on chain.\\n     * @param data A given ChannelData data structure.\\n     * @param channelId Unique identifier for a channel.\\n     */\\n    function _requireMatchingStorage(ChannelData memory data, bytes32 channelId) internal view {\\n        require(_matchesStatus(data, statusOf[channelId]), 'status(ChannelData)!=storage');\\n    }\\n\\n    /**\\n     * @notice Checks that a given ChannelData struct matches a supplied bytes32 when formatted for storage.\\n     * @dev Checks that a given ChannelData struct matches a supplied bytes32 when formatted for storage.\\n     * @param data A given ChannelData data structure.\\n     * @param s Some data in on-chain storage format.\\n     */\\n    function _matchesStatus(ChannelData memory data, bytes32 s) internal pure returns (bool) {\\n        return _generateStatus(data) == s;\\n    }\\n\\n    /**\\n     * @notice Computes the hash of the state corresponding to the input data.\\n     * @dev Computes the hash of the state corresponding to the input data.\\n     * @param turnNum Turn number\\n     * @param isFinal Is the state final?\\n     * @param channelId Unique identifier for the channel\\n     * @param appData Application specific data.\\n     * @param outcome Outcome structure.\\n     * @return The stateHash\\n     */\\n    function _hashState(\\n        bytes32 channelId,\\n        bytes memory appData,\\n        Outcome.SingleAssetExit[] memory outcome,\\n        uint48 turnNum,\\n        bool isFinal\\n    ) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(channelId, appData, outcome, turnNum, isFinal));\\n    }\\n\\n    /**\\n     * @notice Hashes the outcome structure. Internal helper.\\n     * @dev Hashes the outcome structure. Internal helper.\\n     * @param outcome Outcome structure to encode hash.\\n     * @return bytes32 Hash of encoded outcome structure.\\n     */\\n    function _hashOutcome(Outcome.SingleAssetExit[] memory outcome)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(Outcome.encodeExit(outcome));\\n    }\\n\\n    /**\\n     * @notice Computes the unique id of a channel.\\n     * @dev Computes the unique id of a channel.\\n     * @param fixedPart Part of the state that does not change\\n     * @return channelId\\n     */\\n    function _getChannelId(FixedPart memory fixedPart) internal pure returns (bytes32 channelId) {\\n        require(fixedPart.chainId == getChainID(), 'Incorrect chainId');\\n        channelId = keccak256(\\n            abi.encode(\\n                getChainID(),\\n                fixedPart.participants,\\n                fixedPart.channelNonce,\\n                fixedPart.appDefinition,\\n                fixedPart.challengeDuration\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice Returns the last VariablePart from array.\\n     * @dev Returns the last VariablePart from array.\\n     * @param variableParts Array of VariableParts.\\n     * @return VariablePart Last VariablePart from array.\\n     */\\n    function _lastVariablePart(IForceMoveApp.VariablePart[] memory variableParts)\\n        internal\\n        pure\\n        returns (IForceMoveApp.VariablePart memory)\\n    {\\n        return variableParts[variableParts.length - 1];\\n    }\\n}\\n\",\"keccak256\":\"0xc1d4489feaf254bf0c35929d01898d8cce11772c103b839936a45d8428b5fd45\",\"license\":\"MIT\"},\"contracts/StateChannel/MultiAssetHolder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\nimport {ExitFormat as Outcome} from '@statechannels/exit-format/contracts/ExitFormat.sol';\\nimport './ForceMove.sol';\\nimport '@openzeppelin/contracts/math/SafeMath.sol';\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport './interfaces/IMultiAssetHolder.sol';\\n\\n/**\\n@dev An implementation of the IMultiAssetHolder interface. The AssetHolder contract escrows ETH or tokens against state channels. It allows assets to be internally accounted for, and ultimately prepared for transfer from one channel to other channels and/or external destinations, as well as for guarantees to be claimed.\\n */\\ncontract MultiAssetHolder is IMultiAssetHolder, StatusManager {\\n    using SafeMath for uint256;\\n\\n    // *******\\n    // Storage\\n    // *******\\n\\n    /**\\n     * holdings[asset][channelId] is the amount of asset held against channel channelId. 0 address implies ETH\\n     */\\n    mapping(address => mapping(bytes32 => uint256)) public holdings;\\n\\n    // **************\\n    // External methods\\n    // **************\\n\\n    /**\\n     * @notice Deposit ETH or erc20 tokens against a given channelId.\\n     * @dev Deposit ETH or erc20 tokens against a given channelId.\\n     * @param asset erc20 token address, or zero address to indicate ETH\\n     * @param channelId ChannelId to be credited.\\n     * @param expectedHeld The number of wei/tokens the depositor believes are _already_ escrowed against the channelId.\\n     * @param amount The intended number of wei/tokens to be deposited.\\n     */\\n    function deposit(\\n        address asset,\\n        bytes32 channelId,\\n        uint256 expectedHeld,\\n        uint256 amount\\n    ) external payable override {\\n        require(!_isExternalDestination(channelId), 'Deposit to external destination');\\n        uint256 amountDeposited;\\n        // this allows participants to reduce the wait between deposits, while protecting them from losing funds by depositing too early. Specifically it protects against the scenario:\\n        // 1. Participant A deposits\\n        // 2. Participant B sees A's deposit, which means it is now safe for them to deposit\\n        // 3. Participant B submits their deposit\\n        // 4. The chain re-orgs, leaving B's deposit in the chain but not A's\\n        uint256 held = holdings[asset][channelId];\\n        require(held >= expectedHeld, 'holdings < expectedHeld');\\n        require(held < expectedHeld.add(amount), 'holdings already sufficient');\\n\\n        // The depositor wishes to increase the holdings against channelId to amount + expectedHeld\\n        // The depositor need only deposit (at most) amount + (expectedHeld - holdings) (the term in parentheses is non-positive)\\n\\n        amountDeposited = expectedHeld.add(amount).sub(held); // strictly positive\\n        // require successful deposit before updating holdings (protect against reentrancy)\\n        if (asset == address(0)) {\\n            require(msg.value == amount, 'Incorrect msg.value for deposit');\\n        } else {\\n            // require successful deposit before updating holdings (protect against reentrancy)\\n            require(\\n                IERC20(asset).transferFrom(msg.sender, address(this), amountDeposited),\\n                'Could not deposit ERC20s'\\n            );\\n        }\\n\\n        uint256 nowHeld = held.add(amountDeposited);\\n        holdings[asset][channelId] = nowHeld;\\n        emit Deposited(channelId, asset, amountDeposited, nowHeld);\\n\\n        if (asset == address(0)) {\\n            // refund whatever wasn't deposited.\\n            uint256 refund = amount.sub(amountDeposited);\\n            (bool success, ) = msg.sender.call{value: refund}(''); //solhint-disable-line avoid-low-level-calls\\n            require(success, 'Could not refund excess funds');\\n        }\\n    }\\n\\n    /**\\n     * @notice Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries.\\n     * @dev Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries.\\n     * @param assetIndex Will be used to slice the outcome into a single asset outcome.\\n     * @param fromChannelId Unique identifier for state channel to transfer funds *from*.\\n     * @param outcomeBytes The encoded Outcome of this state channel\\n     * @param stateHash The hash of the state stored when the channel finalized.\\n     * @param indices Array with each entry denoting the index of a destination to transfer funds to. An empty array indicates \\\"all\\\".\\n     */\\n    function transfer(\\n        uint256 assetIndex, // TODO consider a uint48?\\n        bytes32 fromChannelId,\\n        bytes memory outcomeBytes,\\n        bytes32 stateHash,\\n        uint256[] memory indices\\n    ) external override {\\n        (\\n            Outcome.SingleAssetExit[] memory outcome,\\n            address asset,\\n            uint256 initialAssetHoldings\\n        ) = _apply_transfer_checks(assetIndex, indices, fromChannelId, stateHash, outcomeBytes); // view\\n\\n        (\\n            Outcome.Allocation[] memory newAllocations,\\n            ,\\n            Outcome.Allocation[] memory exitAllocations,\\n            uint256 totalPayouts\\n        ) = compute_transfer_effects_and_interactions(\\n                initialAssetHoldings,\\n                outcome[assetIndex].allocations,\\n                indices\\n            ); // pure, also performs checks\\n\\n        _apply_transfer_effects(\\n            assetIndex,\\n            asset,\\n            fromChannelId,\\n            stateHash,\\n            outcome,\\n            newAllocations,\\n            initialAssetHoldings,\\n            totalPayouts\\n        );\\n        _apply_transfer_interactions(outcome[assetIndex], exitAllocations);\\n    }\\n\\n    function _apply_transfer_checks(\\n        uint256 assetIndex,\\n        uint256[] memory indices,\\n        bytes32 channelId,\\n        bytes32 stateHash,\\n        bytes memory outcomeBytes\\n    )\\n        internal\\n        view\\n        returns (\\n            Outcome.SingleAssetExit[] memory outcome,\\n            address asset,\\n            uint256 initialAssetHoldings\\n        )\\n    {\\n        _requireIncreasingIndices(indices); // This assumption is relied on by compute_transfer_effects_and_interactions\\n        _requireChannelFinalized(channelId);\\n        _requireMatchingFingerprint(stateHash, keccak256(outcomeBytes), channelId);\\n\\n        outcome = Outcome.decodeExit(outcomeBytes);\\n        asset = outcome[assetIndex].asset;\\n        initialAssetHoldings = holdings[asset][channelId];\\n    }\\n\\n    function compute_transfer_effects_and_interactions(\\n        uint256 initialHoldings,\\n        Outcome.Allocation[] memory allocations,\\n        uint256[] memory indices\\n    )\\n        public\\n        pure\\n        returns (\\n            Outcome.Allocation[] memory newAllocations,\\n            bool allocatesOnlyZeros,\\n            Outcome.Allocation[] memory exitAllocations,\\n            uint256 totalPayouts\\n        )\\n    {\\n        // `indices == []` means \\\"pay out to all\\\"\\n        // Note: by initializing exitAllocations to be an array of fixed length, its entries are initialized to be `0`\\n        exitAllocations = new Outcome.Allocation[](\\n            indices.length > 0 ? indices.length : allocations.length\\n        );\\n        totalPayouts = 0;\\n        newAllocations = new Outcome.Allocation[](allocations.length);\\n        allocatesOnlyZeros = true; // switched to false if there is an item remaining with amount > 0\\n        uint256 surplus = initialHoldings; // tracks funds available during calculation\\n        uint256 k = 0; // indexes the `indices` array\\n\\n        // loop over allocations and decrease surplus\\n        for (uint256 i = 0; i < allocations.length; i++) {\\n            // copy destination, allocationType and metadata parts\\n            newAllocations[i].destination = allocations[i].destination;\\n            newAllocations[i].allocationType = allocations[i].allocationType;\\n            newAllocations[i].metadata = allocations[i].metadata;\\n            // compute new amount part\\n            uint256 affordsForDestination = min(allocations[i].amount, surplus);\\n            if ((indices.length == 0) || ((k < indices.length) && (indices[k] == i))) {\\n                if (allocations[k].allocationType == uint8(Outcome.AllocationType.guarantee))\\n                    revert('cannot transfer a guarantee');\\n                // found a match\\n                // reduce the current allocationItem.amount\\n                newAllocations[i].amount = allocations[i].amount - affordsForDestination;\\n                // increase the relevant exit allocation\\n                exitAllocations[k] = Outcome.Allocation(\\n                    allocations[i].destination,\\n                    affordsForDestination,\\n                    allocations[i].allocationType,\\n                    allocations[i].metadata\\n                );\\n                totalPayouts += affordsForDestination;\\n                // move on to the next supplied index\\n                ++k;\\n            } else {\\n                newAllocations[i].amount = allocations[i].amount;\\n            }\\n            if (newAllocations[i].amount != 0) allocatesOnlyZeros = false;\\n            // decrease surplus by the current amount if possible, else surplus goes to zero\\n            surplus -= affordsForDestination;\\n        }\\n    }\\n\\n    function _apply_transfer_effects(\\n        uint256 assetIndex,\\n        address asset,\\n        bytes32 channelId,\\n        bytes32 stateHash,\\n        Outcome.SingleAssetExit[] memory outcome,\\n        Outcome.Allocation[] memory newAllocations,\\n        uint256 initialHoldings,\\n        uint256 totalPayouts\\n    ) internal {\\n        // update holdings\\n        holdings[asset][channelId] -= totalPayouts;\\n\\n        // store fingerprint of modified outcome\\n        outcome[assetIndex].allocations = newAllocations;\\n        _updateFingerprint(channelId, stateHash, keccak256(abi.encode(outcome)));\\n\\n        // emit the information needed to compute the new outcome stored in the fingerprint\\n        emit AllocationUpdated(channelId, assetIndex, initialHoldings);\\n    }\\n\\n    function _apply_transfer_interactions(\\n        Outcome.SingleAssetExit memory singleAssetExit,\\n        Outcome.Allocation[] memory exitAllocations\\n    ) internal {\\n        // create a new tuple to avoid mutating singleAssetExit\\n        _executeSingleAssetExit(\\n            Outcome.SingleAssetExit(\\n                singleAssetExit.asset,\\n                singleAssetExit.metadata,\\n                exitAllocations\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice Executes a single asset exit by paying out the asset and calling external contracts, as well as updating the holdings stored in this contract.\\n     * @dev Executes a single asset exit by paying out the asset and calling external contracts, as well as updating the holdings stored in this contract.\\n     * @param singleAssetExit The single asset exit to be paid out.\\n     */\\n    function _executeSingleAssetExit(Outcome.SingleAssetExit memory singleAssetExit) internal {\\n        address asset = singleAssetExit.asset;\\n        for (uint256 j = 0; j < singleAssetExit.allocations.length; j++) {\\n            bytes32 destination = singleAssetExit.allocations[j].destination;\\n            uint256 amount = singleAssetExit.allocations[j].amount;\\n            if (_isExternalDestination(destination)) {\\n                _transferAsset(asset, _bytes32ToAddress(destination), amount);\\n            } else {\\n                holdings[asset][destination] += amount;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Transfers the given amount of this AssetHolders's asset type to a supplied ethereum address.\\n     * @dev Transfers the given amount of this AssetHolders's asset type to a supplied ethereum address.\\n     * @param destination ethereum address to be credited.\\n     * @param amount Quantity of assets to be transferred.\\n     */\\n    function _transferAsset(\\n        address asset,\\n        address destination,\\n        uint256 amount\\n    ) internal {\\n        if (asset == address(0)) {\\n            (bool success, ) = destination.call{value: amount}(''); //solhint-disable-line avoid-low-level-calls\\n            require(success, 'Could not transfer ETH');\\n        } else {\\n            IERC20(asset).transfer(destination, amount);\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if a given destination is external (and can therefore have assets transferred to it) or not.\\n     * @dev Checks if a given destination is external (and can therefore have assets transferred to it) or not.\\n     * @param destination Destination to be checked.\\n     * @return True if the destination is external, false otherwise.\\n     */\\n    function _isExternalDestination(bytes32 destination) internal pure returns (bool) {\\n        return uint96(bytes12(destination)) == 0;\\n    }\\n\\n    /**\\n     * @notice Converts an ethereum address to a nitro external destination.\\n     * @dev Converts an ethereum address to a nitro external destination.\\n     * @param participant The address to be converted.\\n     * @return The input address left-padded with zeros.\\n     */\\n    function _addressToBytes32(address participant) internal pure returns (bytes32) {\\n        return bytes32(uint256(participant));\\n    }\\n\\n    /**\\n     * @notice Converts a nitro destination to an ethereum address.\\n     * @dev Converts a nitro destination to an ethereum address.\\n     * @param destination The destination to be converted.\\n     * @return The rightmost 160 bits of the input string.\\n     */\\n    function _bytes32ToAddress(bytes32 destination) internal pure returns (address payable) {\\n        return address(uint160(uint256(destination)));\\n    }\\n\\n    // **************\\n    // Requirers\\n    // **************\\n\\n    /**\\n     * @notice Checks that a given variables hash to the data stored on chain.\\n     * @dev Checks that a given variables hash to the data stored on chain.\\n     */\\n    function _requireMatchingFingerprint(\\n        bytes32 stateHash,\\n        bytes32 outcomeHash,\\n        bytes32 channelId\\n    ) internal view {\\n        (, , uint160 fingerprint) = _unpackStatus(channelId);\\n        require(\\n            fingerprint == _generateFingerprint(stateHash, outcomeHash),\\n            'incorrect fingerprint'\\n        );\\n    }\\n\\n    /**\\n     * @notice Checks that a given channel is in the Finalized mode.\\n     * @dev Checks that a given channel is in the Finalized mode.\\n     * @param channelId Unique identifier for a channel.\\n     */\\n    function _requireChannelFinalized(bytes32 channelId) internal view {\\n        require(_mode(channelId) == ChannelMode.Finalized, 'Channel not finalized.');\\n    }\\n\\n    function _updateFingerprint(\\n        bytes32 channelId,\\n        bytes32 stateHash,\\n        bytes32 outcomeHash\\n    ) internal {\\n        (uint48 turnNumRecord, uint48 finalizesAt, ) = _unpackStatus(channelId);\\n\\n        bytes32 newStatus = _generateStatus(\\n            ChannelData(turnNumRecord, finalizesAt, stateHash, outcomeHash)\\n        );\\n        statusOf[channelId] = newStatus;\\n    }\\n\\n    /**\\n     * @notice Checks that the supplied indices are strictly increasing.\\n     * @dev Checks that the supplied indices are strictly increasing. This allows us allows us to write a more efficient claim function.\\n     */\\n    function _requireIncreasingIndices(uint256[] memory indices) internal pure {\\n        for (uint256 i = 0; i + 1 < indices.length; i++) {\\n            require(indices[i] < indices[i + 1], 'Indices must be sorted');\\n        }\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? b : a;\\n    }\\n\\n    function decodeGuaranteeData(bytes memory data) internal pure returns (bytes32[] memory) {\\n        return abi.decode(data, (bytes32[]));\\n    }\\n}\\n\",\"keccak256\":\"0xde1f5c75dd69badeca5f7668acb3af85382db07e868b15c2aaedc2fe4092222d\",\"license\":\"MIT\"},\"contracts/StateChannel/StatusManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\nimport './interfaces/IStatusManager.sol';\\n\\n/**\\n * @dev The StatusManager is responsible for on-chain storage of the status of active channels\\n */\\ncontract StatusManager is IStatusManager {\\n    mapping(bytes32 => bytes32) public statusOf;\\n\\n    /**\\n     * @notice Computes the ChannelMode for a given channelId.\\n     * @dev Computes the ChannelMode for a given channelId.\\n     * @param channelId Unique identifier for a channel.\\n     */\\n    function _mode(bytes32 channelId) internal view returns (ChannelMode) {\\n        // Note that _unpackStatus(someRandomChannelId) returns (0,0,0), which is\\n        // correct when nobody has written to storage yet.\\n\\n        (, uint48 finalizesAt, ) = _unpackStatus(channelId);\\n        if (finalizesAt == 0) {\\n            return ChannelMode.Open;\\n            // solhint-disable-next-line not-rely-on-time\\n        } else if (finalizesAt <= block.timestamp) {\\n            return ChannelMode.Finalized;\\n        } else {\\n            return ChannelMode.Challenge;\\n        }\\n    }\\n\\n    /**\\n     * @notice Formats the input data for on chain storage.\\n     * @dev Formats the input data for on chain storage.\\n     * @param channelData ChannelData data.\\n     */\\n    function _generateStatus(ChannelData memory channelData)\\n        internal\\n        pure\\n        returns (bytes32 status)\\n    {\\n        // The hash is constructed from left to right.\\n        uint256 result;\\n        uint16 cursor = 256;\\n\\n        // Shift turnNumRecord 208 bits left to fill the first 48 bits\\n        result = uint256(channelData.turnNumRecord) << (cursor -= 48);\\n\\n        // logical or with finalizesAt padded with 160 zeros to get the next 48 bits\\n        result |= (uint256(channelData.finalizesAt) << (cursor -= 48));\\n\\n        // logical or with the last 160 bits of the hash the remaining channelData fields\\n        // (we call this the fingerprint)\\n        result |= uint256(_generateFingerprint(channelData.stateHash, channelData.outcomeHash));\\n\\n        status = bytes32(result);\\n    }\\n\\n    function _generateFingerprint(bytes32 stateHash, bytes32 outcomeHash)\\n        internal\\n        pure\\n        returns (uint160)\\n    {\\n        return uint160(uint256(keccak256(abi.encode(stateHash, outcomeHash))));\\n    }\\n\\n    /**\\n     * @notice Unpacks turnNumRecord, finalizesAt and fingerprint from the status of a particular channel.\\n     * @dev Unpacks turnNumRecord, finalizesAt and fingerprint from the status of a particular channel.\\n     * @param channelId Unique identifier for a state channel.\\n     * @return turnNumRecord A turnNum that (the adjudicator knows) is supported by a signature from each participant.\\n     * @return finalizesAt The unix timestamp when `channelId` will finalize.\\n     * @return fingerprint The last 160 bits of kecca256(stateHash, outcomeHash)\\n     */\\n    function _unpackStatus(bytes32 channelId)\\n        internal\\n        view\\n        returns (\\n            uint48 turnNumRecord,\\n            uint48 finalizesAt,\\n            uint160 fingerprint\\n        )\\n    {\\n        bytes32 status = statusOf[channelId];\\n        uint16 cursor = 256;\\n        turnNumRecord = uint48(uint256(status) >> (cursor -= 48));\\n        finalizesAt = uint48(uint256(status) >> (cursor -= 48));\\n        fingerprint = uint160(uint256(status));\\n    }\\n}\\n\",\"keccak256\":\"0xbd230ef1d6709377aea050fba8c7b252cc931543c8c0defe2c300f1b17c55df4\",\"license\":\"MIT\"},\"contracts/StateChannel/interfaces/IForceMove.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport './IForceMoveApp.sol';\\n\\n/**\\n * @dev The IForceMove interface defines the interface that an implementation of ForceMove should implement. ForceMove protocol allows state channels to be adjudicated and finalized.\\n */\\ninterface IForceMove {\\n    struct Signature {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    struct FixedPart {\\n        uint256 chainId;\\n        address[] participants;\\n        uint48 channelNonce;\\n        address appDefinition;\\n        uint48 challengeDuration;\\n    }\\n\\n    struct State {\\n        // participants sign the hash of this\\n        bytes32 channelId; // keccack(chainId,participants,channelNonce,appDefinition,challengeDuration)\\n        bytes appData;\\n        bytes outcome;\\n        uint48 turnNum;\\n        bool isFinal;\\n    }\\n\\n    /**\\n     * @notice Registers a challenge against a state channel. A challenge will either prompt another participant into clearing the challenge (via one of the other methods), or cause the channel to finalize at a specific time.\\n     * @dev Registers a challenge against a state channel. A challenge will either prompt another participant into clearing the challenge (via one of the other methods), or cause the channel to finalize at a specific time.\\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\\n     * @param variableParts An ordered array of structs, each decribing the properties of the state channel that may change with each state update. Length is from 1 to the number of participants (inclusive).\\n     * @param sigs An array of signatures that support the state with the `largestTurnNum`. There must be one for each participant, e.g.: [sig-from-p0, sig-from-p1, ...]\\n     * @param whoSignedWhat An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\\n     * @param challengerSig The signature of a participant on the keccak256 of the abi.encode of (supportedStateHash, 'forceMove').\\n     */\\n    function challenge(\\n        FixedPart memory fixedPart,\\n        IForceMoveApp.VariablePart[] memory variableParts,\\n        Signature[] memory sigs,\\n        uint8[] memory whoSignedWhat,\\n        Signature memory challengerSig\\n    ) external;\\n\\n    /**\\n     * @notice Repsonds to an ongoing challenge registered against a state channel.\\n     * @dev Repsonds to an ongoing challenge registered against a state channel.\\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\\n     * @param variablePartAB An pair of structs, each decribing the properties of the state channel that may change with each state update (for the challenge state and for the response state).\\n     * @param sig The responder's signature on the `responseStateHash`.\\n     */\\n    function respond(\\n        FixedPart memory fixedPart,\\n        IForceMoveApp.VariablePart[2] memory variablePartAB,\\n        // variablePartAB[0] = challengeVariablePart\\n        // variablePartAB[1] = responseVariablePart\\n        Signature memory sig\\n    ) external;\\n\\n    /**\\n     * @notice Overwrites the `turnNumRecord` stored against a channel by providing a state with higher turn number, supported by a signature from each participant.\\n     * @dev Overwrites the `turnNumRecord` stored against a channel by providing a state with higher turn number, supported by a signature from each participant.\\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\\n     * @param variableParts An ordered array of structs, each decribing the properties of the state channel that may change with each state update.\\n     * @param sigs An array of signatures that support the state with the `largestTurnNum`: one for each participant, in participant order (e.g. [sig of participant[0], sig of participant[1], ...]).\\n     * @param whoSignedWhat An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\\n     */\\n    function checkpoint(\\n        FixedPart memory fixedPart,\\n        IForceMoveApp.VariablePart[] memory variableParts,\\n        Signature[] memory sigs,\\n        uint8[] memory whoSignedWhat\\n    ) external;\\n\\n    /**\\n     * @notice Finalizes a channel by providing a finalization proof. External wrapper for _conclude.\\n     * @dev Finalizes a channel by providing a finalization proof. External wrapper for _conclude.\\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\\n     * @param latestVariablePart Latest variable part in finalization proof. Must have the largest turnNum and the same appData and outcome as all other variable parts in finalization proof.\\n     * @param numStates The number of states in the finalization proof.\\n     * @param whoSignedWhat An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\\n     * @param sigs An array of signatures that support the state with the `largestTurnNum`: one for each participant, in participant order (e.g. [sig of participant[0], sig of participant[1], ...]).\\n     */\\n    function conclude(\\n        FixedPart memory fixedPart,\\n        IForceMoveApp.VariablePart memory latestVariablePart,\\n        uint8 numStates,\\n        uint8[] memory whoSignedWhat,\\n        Signature[] memory sigs\\n    ) external;\\n\\n    // events\\n\\n    /**\\n     * @dev Indicates that a challenge has been registered against `channelId`.\\n     * @param channelId Unique identifier for a state channel.\\n     * @param turnNumRecord A turnNum that (the adjudicator knows) is supported by a signature from each participant.\\n     * @param finalizesAt The unix timestamp when `channelId` will finalize.\\n     * @param isFinal Boolean denoting whether the challenge state is final.\\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\\n     * @param variableParts An ordered array of structs, each decribing the properties of the state channel that may change with each state update.\\n     * @param sigs A list of Signatures that supported the challenge: one for each participant, in participant order (e.g. [sig of participant[0], sig of participant[1], ...]).\\n     * @param whoSignedWhat Indexing information to identify which signature was by which participant\\n     */\\n    event ChallengeRegistered(\\n        bytes32 indexed channelId,\\n        uint48 turnNumRecord,\\n        uint48 finalizesAt,\\n        bool isFinal,\\n        FixedPart fixedPart,\\n        IForceMoveApp.VariablePart[] variableParts,\\n        Signature[] sigs,\\n        uint8[] whoSignedWhat\\n    );\\n\\n    /**\\n     * @dev Indicates that a challenge, previously registered against `channelId`, has been cleared.\\n     * @param channelId Unique identifier for a state channel.\\n     * @param newTurnNumRecord A turnNum that (the adjudicator knows) is supported by a signature from each participant.\\n     */\\n    event ChallengeCleared(bytes32 indexed channelId, uint48 newTurnNumRecord);\\n\\n    /**\\n     * @dev Indicates that a challenge has been registered against `channelId`.\\n     * @param channelId Unique identifier for a state channel.\\n     * @param finalizesAt The unix timestamp when `channelId` finalized.\\n     */\\n    event Concluded(bytes32 indexed channelId, uint48 finalizesAt);\\n}\\n\",\"keccak256\":\"0xe4368bc7a5f4d19ce96a122075dfc2ed603bfcf05792ad69b5861160f4366464\",\"license\":\"MIT\"},\"contracts/StateChannel/interfaces/IForceMoveApp.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport {ExitFormat as Outcome} from '@statechannels/exit-format/contracts/ExitFormat.sol';\\n\\n/**\\n * @dev The IForceMoveApp interface calls for its children to implement an application-specific validTransition function, defining the state machine of a ForceMove state channel DApp.\\n */\\ninterface IForceMoveApp {\\n    struct VariablePart {\\n        Outcome.SingleAssetExit[] outcome;\\n        bytes appData;\\n        uint48 turnNum;\\n        bool isFinal;\\n    }\\n\\n    /**\\n     * @notice Encodes application-specific rules for a particular ForceMove-compliant state channel.\\n     * @dev Encodes application-specific rules for a particular ForceMove-compliant state channel.\\n     * @param a State being transitioned from.\\n     * @param b State being transitioned to.\\n     * @param nParticipants Number of participants in this state channel.\\n     * @return true if the transition conforms to this application's rules, false otherwise\\n     */\\n    function validTransition(\\n        VariablePart calldata a,\\n        VariablePart calldata b,\\n        uint256 nParticipants\\n    ) external pure returns (bool);\\n}\\n\",\"keccak256\":\"0xa4c7f59e310a4aa1ac388ab9b5272c1ef86e959d44615bb8c9f764c1752b2c13\",\"license\":\"MIT\"},\"contracts/StateChannel/interfaces/IMultiAssetHolder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport {ExitFormat as Outcome} from '@statechannels/exit-format/contracts/ExitFormat.sol';\\n\\n/**\\n * @dev The IMultiAssetHolder interface calls for functions that allow assets to be transferred from one channel to other channel and/or external destinations, as well as for guarantees to be claimed.\\n */\\ninterface IMultiAssetHolder {\\n    \\n    /**\\n     * @notice Deposit ETH or erc20 assets against a given destination.\\n     * @dev Deposit ETH or erc20 assets against a given destination.\\n     * @param asset erc20 token address, or zero address to indicate ETH\\n     * @param destination ChannelId to be credited.\\n     * @param expectedHeld The number of wei the depositor believes are _already_ escrowed against the channelId.\\n     * @param amount The intended number of wei to be deposited.\\n     */\\n    function deposit(\\n        address asset,\\n        bytes32 destination,\\n        uint256 expectedHeld,\\n        uint256 amount\\n    ) external payable;\\n\\n    /**\\n     * @notice Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries.\\n     * @dev Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries.\\n     * @param assetIndex Will be used to slice the outcome into a single asset outcome.\\n     * @param fromChannelId Unique identifier for state channel to transfer funds *from*.\\n     * @param outcomeBytes The encoded Outcome of this state channel\\n     * @param stateHash The hash of the state stored when the channel finalized.\\n     * @param indices Array with each entry denoting the index of a destination to transfer funds to. An empty array indicates \\\"all\\\".\\n     */\\n    function transfer(\\n        uint256 assetIndex, // TODO consider a uint48?\\n        bytes32 fromChannelId,\\n        bytes memory outcomeBytes,\\n        bytes32 stateHash,\\n        uint256[] memory indices\\n    ) external;\\n\\n    /**\\n     * @dev Indicates that `amountDeposited` has been deposited into `destination`.\\n     * @param destination The channel being deposited into.\\n     * @param amountDeposited The amount being deposited.\\n     * @param destinationHoldings The new holdings for `destination`.\\n     */\\n    event Deposited(\\n        bytes32 indexed destination,\\n        address asset,\\n        uint256 amountDeposited,\\n        uint256 destinationHoldings\\n    );\\n\\n    /**\\n     * @dev Indicates the assetOutcome for this channelId and assetIndex has changed due to a transfer or claim. Includes sufficient data to compute:\\n     * - the new assetOutcome\\n     * - the new holdings for this channelId and any others that were transferred to\\n     * - the payouts to external destinations\\n     * @param channelId The channelId of the funds being withdrawn.\\n     * @param initialHoldings holdings[asset][channelId] **before** the allocations were updated. The asset in question can be inferred from the calldata of the transaction (it might be \\\"all assets\\\")\\n     */\\n    event AllocationUpdated(bytes32 indexed channelId, uint256 assetIndex, uint256 initialHoldings);\\n}\\n\",\"keccak256\":\"0x2949837d1e723d8604a2916fc96a7fb407218aff97595a3f1ac0921fd7053109\",\"license\":\"MIT\"},\"contracts/StateChannel/interfaces/IStatusManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\ninterface IStatusManager {\\n    enum ChannelMode {\\n        Open,\\n        Challenge,\\n        Finalized\\n    }\\n\\n    struct ChannelData {\\n        uint48 turnNumRecord;\\n        uint48 finalizesAt;\\n        bytes32 stateHash; // keccak256(abi.encode(State))\\n        bytes32 outcomeHash;\\n    }\\n}\\n\",\"keccak256\":\"0x140028cd72d33b61ea22c6274bfb3fbf0809cddc9796954252011e987e9864f7\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506147a4806100206000396000f3fe6080604052600436106100e85760003560e01c806366d1b8a21161008a578063af69c9d711610059578063af69c9d714610279578063be5c2a3114610299578063c36b7e4e146102b9578063c7df14e2146102d9576100e8565b806366d1b8a2146101ec57806372c7f16d1461020c578063800399821461022c5780638bf6ed391461024c576100e8565b80632fb1d270116100c65780632fb1d270146101755780633033730e14610188578063552cfa50146101a8578063564b81ef146101d7576100e8565b806311e9f178146100ed578063166e56cd14610126578063180f6ff014610153575b600080fd5b3480156100f957600080fd5b5061010d610108366004613197565b6102f9565b60405161011d9493929190614197565b60405180910390f35b34801561013257600080fd5b50610146610141366004612d78565b610649565b60405161011d91906141f7565b34801561015f57600080fd5b5061017361016e3660046130d3565b610666565b005b610173610183366004612db0565b61068f565b34801561019457600080fd5b506101736101a336600461325e565b610937565b3480156101b457600080fd5b506101c86101c3366004612e61565b6109b7565b60405161011d939291906145df565b3480156101e357600080fd5b506101466109d2565b3480156101f857600080fd5b50610173610207366004613002565b6109d6565b34801561021857600080fd5b50610173610227366004612f51565b610b44565b34801561023857600080fd5b506101736102473660046130d3565b610ba2565b34801561025857600080fd5b5061026c610267366004613206565b610baf565b60405161011d91906141e9565b34801561028557600080fd5b50610173610294366004612e7e565b610bc6565b3480156102a557600080fd5b5061026c6102b43660046132f2565b610f60565b3480156102c557600080fd5b506101736102d4366004612ee0565b610fe5565b3480156102e557600080fd5b506101466102f4366004612e61565b611135565b606060006060600080855111610310578551610313565b84515b67ffffffffffffffff8111801561032957600080fd5b5060405190808252806020026020018201604052801561036357816020015b61035061242d565b8152602001906001900390816103485790505b50915060009050855167ffffffffffffffff8111801561038257600080fd5b506040519080825280602002602001820160405280156103bc57816020015b6103a961242d565b8152602001906001900390816103a15790505b50935060019250866000805b885181101561063d578881815181106103dd57fe5b6020026020010151600001518782815181106103f557fe5b6020026020010151600001818152505088818151811061041157fe5b60200260200101516040015187828151811061042957fe5b60200260200101516040019060ff16908160ff168152505088818151811061044d57fe5b60200260200101516060015187828151811061046557fe5b60200260200101516060018190525060006104978a838151811061048557fe5b60200260200101516020015185611147565b90508851600014806104c657508851831080156104c65750818984815181106104bc57fe5b6020026020010151145b156105d857600260ff168a84815181106104dc57fe5b60200260200101516040015160ff1614156105125760405162461bcd60e51b815260040161050990614383565b60405180910390fd5b808a838151811061051f57fe5b6020026020010151602001510388838151811061053857fe5b6020026020010151602001818152505060405180608001604052808b848151811061055f57fe5b60200260200101516000015181526020018281526020018b848151811061058257fe5b60200260200101516040015160ff1681526020018b84815181106105a257fe5b6020026020010151606001518152508684815181106105bd57fe5b6020026020010181905250808501945082600101925061060d565b8982815181106105e457fe5b6020026020010151602001518883815181106105fc57fe5b602002602001015160200181815250505b87828151811061061957fe5b60200260200101516020015160001461063157600096505b909203916001016103c8565b50505093509350935093565b600160209081526000928352604080842090915290825290205481565b60006106758686868686611161565b85519091506106879082906000610bc6565b505050505050565b61069883611335565b156106b55760405162461bcd60e51b815260040161050990614433565b6001600160a01b0384166000908152600160209081526040808320868452909152812054838110156106f95760405162461bcd60e51b8152600401610509906142c3565b6107038484611341565b81106107215760405162461bcd60e51b815260040161050990614483565b6107358161072f8686611341565b9061139b565b91506001600160a01b038616610769578234146107645760405162461bcd60e51b815260040161050990614493565b610820565b6040517f23b872dd0000000000000000000000000000000000000000000000000000000081526001600160a01b038716906323b872dd906107b290339030908790600401614139565b602060405180830381600087803b1580156107cc57600080fd5b505af11580156107e0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108049190612e44565b6108205760405162461bcd60e51b8152600401610509906143c3565b600061082c8284611341565b6001600160a01b03881660009081526001602090815260408083208a8452909152908190208290555190915086907f2dcdaad87b561ba5a69835009b4c53ef9d3c41ca6cc9574049187659d6c6a7159061088b908a908790869061417c565b60405180910390a26001600160a01b03871661092e5760006108ad858561139b565b90506000336001600160a01b0316826040516108c89061412e565b60006040518083038185875af1925050503d8060008114610905576040519150601f19603f3d011682016040523d82523d6000602084013e61090a565b606091505b505090508061092b5760405162461bcd60e51b8152600401610509906144b3565b50505b50505050505050565b6000806000610949888589888a6113f8565b925092509250600080600061097684878d8151811061096457fe5b602002602001015160400151896102f9565b9350935050925061098d8b868c8b8a888a88611476565b6109aa868c8151811061099c57fe5b602002602001015183611534565b5050505050505050505050565b60008060006109c58461156c565b9196909550909350915050565b4690565b6109ea856020015151855185518551610f60565b5060006109f68661158a565b90506000610a0386611600565b6040015190506000610a1483611627565b6002811115610a1f57fe5b1415610a3457610a2f8282611671565b610a63565b6001610a3f83611627565b6002811115610a4a57fe5b1415610a5a57610a2f82826116b5565b610a63826116f3565b6000610a7287848a898961172a565b9050610a8381896020015186611798565b827fbc93eb35d1e2104744f8837e55265ad2f79d1c3f0843e40e757505a1c9007f38838a608001514201610ab68b611600565b606001518c8c8c8c604051610ad1979695949392919061455c565b60405180910390a2610b2860405180608001604052808465ffffffffffff1681526020018a60800151420165ffffffffffff168152602001838152602001610b21610b1b8b611600565b516117f8565b9052611811565b6000938452602084905260409093209290925550505050505050565b610b58846020015151845184518451610f60565b506000610b648561158a565b90506000610b7185611600565b604001519050610b80826116f3565b610b8a82826116b5565b610b97858388878761172a565b50610687828261188b565b6106878585858585611161565b6000610bbc848484611912565b90505b9392505050565b610bcf836119ed565b610be281610bdc846117f8565b85611a20565b815160019060009067ffffffffffffffff81118015610c0057600080fd5b50604051908082528060200260200182016040528015610c3a57816020015b610c27612453565b815260200190600190039081610c1f5790505b5090506000845167ffffffffffffffff81118015610c5757600080fd5b50604051908082528060200260200182016040528015610c81578160200160208202803683370190505b5090506000855167ffffffffffffffff81118015610c9e57600080fd5b50604051908082528060200260200182016040528015610cc8578160200160208202803683370190505b50905060005b8651811015610e63576000878281518110610ce557fe5b602002602001015190506000816040015190506000898481518110610d0657fe5b602002602001015160000151905060016000826001600160a01b03166001600160a01b0316815260200190815260200160002060008c815260200190815260200160002054868581518110610d5757fe5b602002602001018181525050600080600080610dc98a8981518110610d7857fe5b602002602001015187600067ffffffffffffffff81118015610d9957600080fd5b50604051908082528060200260200182016040528015610dc3578160200160208202803683370190505b506102f9565b935093509350935082610ddb5760009b505b80898981518110610de857fe5b602002602001018181525050838e8981518110610e0157fe5b6020026020010151604001819052506040518060600160405280866001600160a01b0316815260200188602001518152602001838152508b8981518110610e4457fe5b6020026020010181905250505050505050508080600101915050610cce565b5060005b8651811015610f29576000878281518110610e7e57fe5b6020026020010151600001519050828281518110610e9857fe5b6020908102919091018101516001600160a01b03831660009081526001835260408082208d8352909352919091208054919091039055835189907fb3917fd12b23b8d48703d554ab284c5b1912bb5c67e710c7534a56c130637679908490879082908110610f0257fe5b6020026020010151604051610f18929190614540565b60405180910390a250600101610e67565b508315610f4457600087815260208190526040812055610f57565b610f578786610f52896117f8565b611a69565b61092e83611acf565b6000838510158015610f725750600084115b610f8e5760405162461bcd60e51b815260040161050990614363565b8483148015610f9c57508482145b610fb85760405162461bcd60e51b8152600401610509906143d3565b60ff851115610fd95760405162461bcd60e51b815260040161050990614373565b5060015b949350505050565b6000610ff08461158a565b9050600080610ffe8361156c565b50865160208101519051929450909250600091611029918691868a865b602002015160600151611aff565b60208781015190810151905191925060009161104e9187916001888101908c9061101b565b90506110a360405180608001604052808665ffffffffffff1681526020018565ffffffffffff16815260200184815260200161109b8a60006002811061109057fe5b6020020151516117f8565b905286611b3b565b6020880151805165ffffffffffff6001870116816110bd57fe5b06815181106110c857fe5b60200260200101516001600160a01b03166110e38288611b4e565b6001600160a01b0316146111095760405162461bcd60e51b8152600401610509906143a3565b61111d886020015151888a60600151611912565b5061112b858560010161188b565b5050505050505050565b60006020819052908152604090205481565b60008183116111565782611158565b815b90505b92915050565b600061116c8661158a565b9050611177816116f3565b61118d8660200151518560ff1684518651610f60565b508360ff16856040015160010165ffffffffffff1610156111c05760405162461bcd60e51b815260040161050990614443565b60008460ff1667ffffffffffffffff811180156111dc57600080fd5b50604051908082528060200260200182016040528015611206578160200160208202803683370190505b50905060005b8560ff168165ffffffffffff16101561126a5761124383886020015189600001518960ff16856001018c6040015101036001611aff565b828265ffffffffffff168151811061125757fe5b602090810291909101015260010161120c565b5061128086604001518860200151838688611c00565b61129c5760405162461bcd60e51b815260040161050990614423565b6112dd6040518060800160405280600065ffffffffffff1681526020014265ffffffffffff1681526020016000801b8152602001610b2189600001516117f8565b60008084815260200190815260200160002081905550817f4f465027a3d06ea73dd12be0f5c5fc0a34e21f19d6eaed4834a7a944edabc90142604051611323919061454e565b60405180910390a25095945050505050565b60a081901c155b919050565b600082820183811015611158576040805162461bcd60e51b815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b6000828211156113f2576040805162461bcd60e51b815260206004820152601e60248201527f536166654d6174683a207375627472616374696f6e206f766572666c6f770000604482015290519081900360640190fd5b50900390565b606060008061140687611cd6565b61140f866119ed565b61142185858051906020012088611a20565b61142a84611d35565b925082888151811061143857fe5b602090810291909101810151516001600160a01b03811660009081526001835260408082209982529890925296902054929895975091955050505050565b6001600160a01b03871660009081526001602090815260408083208984529091529020805482900390558351839085908a9081106114b057fe5b6020026020010151604001819052506114f08686866040516020016114d591906141d8565b60405160208183030381529060405280519060200120611a69565b857fb3917fd12b23b8d48703d554ab284c5b1912bb5c67e710c7534a56c1306376798984604051611522929190614540565b60405180910390a25050505050505050565b611568604051806060016040528084600001516001600160a01b031681526020018460200151815260200183815250611d4b565b5050565b60009081526020819052604090205460d081901c9160a082901c9190565b60006115946109d2565b8251146115b35760405162461bcd60e51b8152600401610509906142d3565b6115bb6109d2565b82602001518360400151846060015185608001516040516020016115e39594939291906144f7565b604051602081830303815290604052805190602001209050919050565b61160861247d565b8160018351038151811061161857fe5b60200260200101519050919050565b6000806116338361156c565b5091505065ffffffffffff811661164e57600091505061133c565b428165ffffffffffff161161166757600291505061133c565b600191505061133c565b600061167c8361156c565b505090508065ffffffffffff168265ffffffffffff1610156116b05760405162461bcd60e51b8152600401610509906142f3565b505050565b60006116c08361156c565b505090508065ffffffffffff168265ffffffffffff16116116b05760405162461bcd60e51b8152600401610509906142b3565b60026116fe82611627565b600281111561170957fe5b14156117275760405162461bcd60e51b8152600401610509906142e3565b50565b600080611738878787611df7565b905061175761174688611600565b604001518660200151838787611c00565b6117735760405162461bcd60e51b815260040161050990614353565b8060018251038151811061178357fe5b60200260200101519150505b95945050505050565b60006117ca846040516020016117ae919061425f565b6040516020818303038152906040528051906020012083611b4e565b90506117d68184611f85565b6117f25760405162461bcd60e51b815260040161050990614333565b50505050565b600061180382611fdb565b805190602001209050919050565b805160208201516040830151606084015160009360d01b7fffffffffffff00000000000000000000000000000000000000000000000000001660a093841b79ffffffffffff00000000000000000000000000000000000000001617929161187791612004565b6001600160a01b0316919091179392505050565b6040805160808101825265ffffffffffff8316815260006020820181905291810182905260608101919091526118c090611811565b60008084815260200190815260200160002081905550817f07da0a0674fb921e484018c8b81d80e292745e5d8ed134b580c8b9c631c5e9e082604051611906919061454e565b60405180910390a25050565b60008061191f8585612030565b9050600181600181111561192f57fe5b1415610fd957835160208501516040517f2934b2e40000000000000000000000000000000000000000000000000000000081526001600160a01b03861692632934b2e492611981928a906004016144c3565b60206040518083038186803b15801561199957600080fd5b505afa1580156119ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119d19190612e44565b610fd95760405162461bcd60e51b815260040161050990614303565b60026119f882611627565b6002811115611a0357fe5b146117275760405162461bcd60e51b815260040161050990614453565b6000611a2b8261156c565b92505050611a398484612004565b6001600160a01b0316816001600160a01b0316146117f25760405162461bcd60e51b8152600401610509906143b3565b600080611a758561156c565b50915091506000611ab560405180608001604052808565ffffffffffff1681526020018465ffffffffffff16815260200187815260200186815250611811565b600096875260208790526040909620959095555050505050565b60005b815181101561156857611af7828281518110611aea57fe5b6020026020010151611d4b565b600101611ad2565b60008585858585604051602001611b1a959493929190614205565b60405160208183030381529060405280519060200120905095945050505050565b611b458282612125565b6115688161215b565b60008083604051602001611b62919061410e565b604051602081830303815290604052805190602001209050600060018285600001518660200151876040015160405160008152602001604052604051611bab949392919061427e565b6020604051602081039080840390855afa158015611bcd573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b038116610fdd5760405162461bcd60e51b815260040161050990614393565b8351835160009190611c148489848461218e565b611c305760405162461bcd60e51b8152600401610509906143e3565b60005b82811015611cc7576000611c8388878481518110611c4d57fe5b602002602001015160ff1681518110611c6257fe5b6020026020010151888481518110611c7657fe5b6020026020010151611b4e565b9050888281518110611c9157fe5b60200260200101516001600160a01b0316816001600160a01b031614611cbe57600094505050505061178f565b50600101611c33565b50600198975050505050505050565b60005b815181600101101561156857818160010181518110611cf457fe5b6020026020010151828281518110611d0857fe5b602002602001015110611d2d5760405162461bcd60e51b815260040161050990614323565b600101611cd9565b60608180602001905181019061115b9190612e0f565b805160005b8260400151518110156116b057600083604001518281518110611d6f57fe5b6020026020010151600001519050600084604001518381518110611d8f57fe5b6020026020010151602001519050611da682611335565b15611dc357611dbe84611db884612218565b8361221b565b611ded565b6001600160a01b038416600090815260016020908152604080832085845290915290208054820190555b5050600101611d50565b60606000845167ffffffffffffffff81118015611e1357600080fd5b50604051908082528060200260200182016040528015611e3d578160200160208202803683370190505b50905060005b85518165ffffffffffff161015611f7c57611edd85878365ffffffffffff1681518110611e6c57fe5b602002602001015160200151888465ffffffffffff1681518110611e8c57fe5b602002602001015160000151898565ffffffffffff1681518110611eac57fe5b6020026020010151604001518a8665ffffffffffff1681518110611ecc57fe5b602002602001015160600151611aff565b828265ffffffffffff1681518110611ef157fe5b60200260200101818152505060018651038165ffffffffffff161015611f7457611f728460200151516040518060400160405280898565ffffffffffff1681518110611f3957fe5b60200260200101518152602001898560010165ffffffffffff1681518110611f5d57fe5b60200260200101518152508660600151611912565b505b600101611e43565b50949350505050565b6000805b8251811015611fd157828181518110611f9e57fe5b60200260200101516001600160a01b0316846001600160a01b03161415611fc957600191505061115b565b600101611f89565b5060009392505050565b606081604051602001611fee91906141d8565b6040516020818303038152906040529050919050565b604080516020808201949094528082019290925280518083038201815260609092019052805191012090565b60208101516060015160009015612077576120568260015b602002015151835151612344565b6120725760405162461bcd60e51b815260040161050990614463565b61211c565b8151606001511561209a5760405162461bcd60e51b8152600401610509906144a3565b6002830282600160200201516040015165ffffffffffff161015612114576120c3826001612048565b6120df5760405162461bcd60e51b8152600401610509906143f3565b6020828101518101518351909101516120f89190612360565b6120725760405162461bcd60e51b815260040161050990614413565b50600161115b565b50600092915050565b60008181526020819052604090205461213f9083906123c4565b6115685760405162461bcd60e51b815260040161050990614403565b600161216682611627565b600281111561217157fe5b146117275760405162461bcd60e51b815260040161050990614313565b6000828551146121b05760405162461bcd60e51b815260040161050990614473565b60005b8381101561220c57600084828765ffffffffffff16870103816121d257fe5b06905083818884815181106121e357fe5b602002602001015160ff1601600101101561220357600092505050610fdd565b506001016121b3565b50600195945050505050565b90565b6001600160a01b0383166122ab576000826001600160a01b0316826040516122429061412e565b60006040518083038185875af1925050503d806000811461227f576040519150601f19603f3d011682016040523d82523d6000602084013e612284565b606091505b50509050806122a55760405162461bcd60e51b815260040161050990614343565b506116b0565b6040517fa9059cbb0000000000000000000000000000000000000000000000000000000081526001600160a01b0384169063a9059cbb906122f29085908590600401614161565b602060405180830381600087803b15801561230c57600080fd5b505af1158015612320573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117f29190612e44565b600061115861235284611fdb565b61235b84611fdb565b6123d8565b81518151600091600191811480831461237c57600092506123ba565b600160208701838101602088015b6002848385100114156123b55780518351146123a95760009650600093505b6020928301920161238a565b505050505b5090949350505050565b6000816123d084611811565b149392505050565b8151815160009160019181148083146123f457600092506123ba565b600160208701838101602088015b6002848385100114156123b55780518351146124215760009650600093505b60209283019201612402565b604080516080810182526000808252602082018190529181019190915260608082015290565b604051806060016040528060006001600160a01b0316815260200160608152602001606081525090565b60405180608001604052806060815260200160608152602001600065ffffffffffff1681526020016000151581525090565b60006124c26124bd84614631565b614607565b905080838252602082019050828560208602850111156124e157600080fd5b60005b8581101561250b576124f68783612827565b835260209283019291909101906001016124e4565b5050509392505050565b60006125236124bd84614631565b8381529050602081018260005b8581101561250b578135850161254688826129e6565b8452506020928301929190910190600101612530565b600061256a6124bd84614631565b8381529050602081018260005b8581101561250b578151850161258d8882612a69565b8452506020928301929190910190600101612577565b60006125b16124bd84614631565b838152905060208101826060850281018610156125cd57600080fd5b60005b8581101561250b576125e28783612b74565b8352602090920191606091909101906001016125d0565b60006126076124bd84614631565b8381529050602081018260005b8581101561250b578135850161262a8882612bc1565b8452506020928301929190910190600101612614565b600061264e6124bd84614631565b8381529050602081018260005b8581101561250b57815185016126718882612c4b565b845250602092830192919091019060010161265b565b60006126956124bd84614655565b9050808260005b8581101561250b57813585016126b28882612cc8565b845250602092830192919091019060010161269c565b60006126d66124bd84614631565b8381529050602081018260005b8581101561250b57813585016126f98882612cc8565b84525060209283019291909101906001016126e3565b600061271d6124bd84614631565b9050808382526020820190508285602086028501111561273c57600080fd5b60005b8581101561250b576127518783612990565b8352602092830192919091019060010161273f565b60006127746124bd84614631565b9050808382526020820190508285602086028501111561279357600080fd5b60005b8581101561250b576127a88783612d62565b83526020928301929190910190600101612796565b60006127cb6124bd84614676565b9050828152602081018484840111156127e357600080fd5b6127ee8482856146f2565b509392505050565b60006128046124bd84614676565b90508281526020810184848401111561281c57600080fd5b6127ee8482856146fe565b803561115b81614736565b805161115b81614736565b600082601f83011261284d578081fd5b8135610fdd8482602086016124af565b600082601f83011261286d578081fd5b8135610fdd848260208601612515565b600082601f83011261288d578081fd5b8151610fdd84826020860161255c565b600082601f8301126128ad578081fd5b8135610fdd8482602086016125a3565b600082601f8301126128cd578081fd5b8135610fdd8482602086016125f9565b600082601f8301126128ed578081fd5b8151610fdd848260208601612640565b600082601f83011261290d578081fd5b6002610fdd848285612687565b600082601f83011261292a578081fd5b8135610fdd8482602086016126c8565b600082601f83011261294a578081fd5b8135610fdd84826020860161270f565b600082601f83011261296a578081fd5b8135610fdd848260208601612766565b803561115b8161474a565b805161115b8161474a565b803561115b81614753565b805161115b81614753565b600082601f8301126129b6578081fd5b8135610fdd8482602086016127bd565b600082601f8301126129d6578081fd5b8151610fdd8482602086016127f6565b6000608082840312156129f7578081fd5b612a016080614607565b90506000612a0f8484612990565b818301526020612a2185828601612990565b908301526040612a3385858301612d62565b90830152606083013567ffffffffffffffff811115612a50578182fd5b612a5c858286016129a6565b6060840152505092915050565b600060808284031215612a7a578081fd5b612a846080614607565b90506000612a92848461299b565b818301526020612aa48582860161299b565b908301526040612ab685858301612d6d565b90830152606083015167ffffffffffffffff811115612ad3578182fd5b612a5c858286016129c6565b600060a08284031215612af0578081fd5b612afa60a0614607565b90506000612b088484612990565b81830152602083013567ffffffffffffffff811115612b25578182fd5b612b318582860161283d565b602084015250506040612b4684828501612d57565b908201526060612b5884848301612827565b908201526080612b6a84848301612d57565b9082015292915050565b600060608284031215612b85578081fd5b612b8f6060614607565b90506000612b9d8484612d62565b908201526020612baf84848301612990565b908201526040612b6a84848301612990565b600060608284031215612bd2578081fd5b612bdc6060614607565b90506000612bea8484612827565b81830152602083013567ffffffffffffffff811115612c07578182fd5b612c13858286016129a6565b602084015250604083013567ffffffffffffffff811115612c32578182fd5b612c3e8582860161285d565b6040840152505092915050565b600060608284031215612c5c578081fd5b612c666060614607565b90506000612c748484612832565b81830152602083015167ffffffffffffffff811115612c91578182fd5b612c9d858286016129c6565b602084015250604083015167ffffffffffffffff811115612cbc578182fd5b612c3e8582860161287d565b600060808284031215612cd9578081fd5b612ce36080614607565b9050813567ffffffffffffffff811115612cfc57600080fd5b612d08848285016128bd565b825250602082013567ffffffffffffffff811115612d2557600080fd5b612d31848285016129a6565b6020830152506040612d4584828501612d57565b908201526060612b6a8484830161297a565b803561115b8161475c565b803561115b81614765565b805161115b81614765565b60008060408385031215612d8a578182fd5b612d9684838501612827565b91506020612da685828601612990565b9150509250929050565b60008060008060808587031215612dc5578182fd5b612dd186838701612827565b93506020612de187828801612990565b9350506040612df287828801612990565b9250506060612e0387828801612990565b91505092959194509250565b600060208284031215612e20578081fd5b8082015167ffffffffffffffff811115612e38578182fd5b610fdd848285016128dd565b600060208284031215612e55578081fd5b61115883828401612985565b600060208284031215612e72578081fd5b61115883828401612990565b600080600060608486031215612e92578081fd5b612e9e85828601612990565b9250602084013567ffffffffffffffff811115612eb9578182fd5b612ec5868287016128bd565b9250506040612ed686828701612990565b9150509250925092565b600080600060a08486031215612ef4578081fd5b8084013567ffffffffffffffff811115612f0c578182fd5b612f1886828701612adf565b935050602084013567ffffffffffffffff811115612f34578182fd5b612f40868287016128fd565b9250506040612ed686828701612b74565b60008060008060808587031215612f66578182fd5b8185013567ffffffffffffffff811115612f7e578283fd5b612f8a87828801612adf565b945050602085013567ffffffffffffffff811115612fa6578283fd5b612fb28782880161291a565b935050604085013567ffffffffffffffff811115612fce578283fd5b612fda8782880161289d565b925050606085013567ffffffffffffffff811115612ff6578182fd5b612e038782880161295a565b600080600080600060e08688031215613019578283fd5b8286013567ffffffffffffffff811115613031578384fd5b61303d88828901612adf565b955050602086013567ffffffffffffffff811115613059578384fd5b6130658882890161291a565b945050604086013567ffffffffffffffff811115613081578384fd5b61308d8882890161289d565b935050606086013567ffffffffffffffff8111156130a9578182fd5b6130b58882890161295a565b92505060806130c688828901612b74565b9150509295509295909350565b600080600080600060a086880312156130ea578283fd5b8286013567ffffffffffffffff811115613102578384fd5b61310e88828901612adf565b955050602086013567ffffffffffffffff81111561312a578384fd5b61313688828901612cc8565b945050604061314788828901612d62565b935050606086013567ffffffffffffffff811115613163578182fd5b61316f8882890161295a565b925050608086013567ffffffffffffffff81111561318b578182fd5b6130c68882890161289d565b6000806000606084860312156131ab578081fd5b6131b785828601612990565b9250602084013567ffffffffffffffff8111156131d2578182fd5b6131de8682870161285d565b925050604084013567ffffffffffffffff8111156131fa578182fd5b612ed68682870161293a565b60008060006060848603121561321a578081fd5b61322685828601612990565b9250602084013567ffffffffffffffff811115613241578182fd5b61324d868287016128fd565b9250506040612ed686828701612827565b600080600080600060a08688031215613275578283fd5b61328187848801612990565b9450602061329188828901612990565b945050604086013567ffffffffffffffff8111156132ad578384fd5b6132b9888289016129a6565b93505060606132ca88828901612990565b925050608086013567ffffffffffffffff8111156132e6578182fd5b6130c68882890161293a565b60008060008060808587031215613307578182fd5b612dd186838701612990565b600061331f838361337a565b505060200190565b60006111588383613f68565b600061333f8383614021565b505060600190565b60006111588383614053565b60006111588383614099565b600061331f8383614105565b613374816146e1565b82525050565b613374816146b4565b600061338e826146a7565b61339881856146ab565b93506133a3836146a1565b825b828110156133cf5781516133b98782613313565b9650506133c5826146a1565b91506001016133a5565b5093949350505050565b60006133e4826146a7565b6133ee81856146ab565b93506133f9836146a1565b825b828110156133cf57815161340f8782613313565b96505061341b826146a1565b91506001016133fb565b6000613430826146a7565b61343a81856146ab565b93508360208202850161344c856146a1565b845b8481101561348457838303885281516134678482613327565b935050613473826146a1565b60209890980197915060010161344e565b50909695505050505050565b600061349b826146a7565b6134a581856146ab565b9350836020820285016134b7856146a1565b845b8481101561348457838303885281516134d28482613327565b9350506134de826146a1565b6020989098019791506001016134b9565b60006134fa826146a7565b61350481856146ab565b935061350f836146a1565b825b828110156133cf5781516135258782613333565b965050613531826146a1565b9150600101613511565b6000613546826146a7565b61355081856146ab565b935083602082028501613562856146a1565b845b84811015613484578383038852815161357d8482613347565b935050613589826146a1565b602098909801979150600101613564565b60006135a5826146a7565b6135af81856146ab565b9350836020820285016135c1856146a1565b845b8481101561348457838303885281516135dc8482613347565b9350506135e8826146a1565b6020989098019791506001016135c3565b6000613604826146a7565b61360e81856146ab565b935083602082028501613620856146a1565b845b84811015613484578383038852815161363b8482613353565b935050613647826146a1565b602098909801979150600101613622565b6000613663826146a7565b61366d81856146ab565b9350613678836146a1565b825b828110156133cf57815161368e878261335f565b96505061369a826146a1565b915060010161367a565b613374816146bf565b61337481612218565b6133746136c282612218565b612218565b60006136d2826146a7565b6136dc81856146ab565b93506136ec8185602086016146fe565b6136f58161472c565b9093019392505050565b600061370c601c836146ab565b7f7475726e4e756d5265636f7264206e6f7420696e637265617365642e0000000091810191909152602001919050565b60006137496017836146ab565b7f686f6c64696e6773203c20657870656374656448656c6400000000000000000091810191909152602001919050565b60006137866011836146ab565b7f496e636f727265637420636861696e496400000000000000000000000000000091810191909152602001919050565b60006137c3601c8361133c565b7f19457468657265756d205369676e6564204d6573736167653a0a33320000000091810191909152601c01919050565b60006138006012836146ab565b7f4368616e6e656c2066696e616c697a65642e000000000000000000000000000091810191909152602001919050565b600061383d6018836146ab565b7f7475726e4e756d5265636f7264206465637265617365642e000000000000000091810191909152602001919050565b600061387a601f836146ab565b7f496e76616c696420466f7263654d6f7665417070205472616e736974696f6e0091810191909152602001919050565b60006138b76015836146ab565b7f4e6f206f6e676f696e67206368616c6c656e67652e000000000000000000000091810191909152602001919050565b60006138f46016836146ab565b7f496e6469636573206d75737420626520736f727465640000000000000000000091810191909152602001919050565b6000613931601f836146ab565b7f4368616c6c656e676572206973206e6f742061207061727469636970616e740091810191909152602001919050565b600061396e6016836146ab565b7f436f756c64206e6f74207472616e73666572204554480000000000000000000091810191909152602001919050565b60006139ab6012836146ab565b7f496e76616c6964207369676e617475726573000000000000000000000000000091810191909152602001919050565b60006139e8601d836146ab565b7f496e73756666696369656e74206f72206578636573732073746174657300000091810191909152602001919050565b6000613a256016836146ab565b7f546f6f206d616e79207061727469636970616e7473210000000000000000000091810191909152602001919050565b6000613a626009836146ab565b7f666f7263654d6f7665000000000000000000000000000000000000000000000091810191909152602001919050565b6000613a9f601b836146ab565b7f63616e6e6f74207472616e7366657220612067756172616e746565000000000091810191909152602001919050565b6000613adc6011836146ab565b7f496e76616c6964207369676e617475726500000000000000000000000000000091810191909152602001919050565b6000613b19601b836146ab565b7f5369676e6572206e6f7420617574686f72697a6564206d6f766572000000000091810191909152602001919050565b6000613b566015836146ab565b7f696e636f72726563742066696e6765727072696e74000000000000000000000091810191909152602001919050565b6000613b936018836146ab565b7f436f756c64206e6f74206465706f73697420455243323073000000000000000091810191909152602001919050565b6000613bd06020836146ab565b7f426164207c7369676e6174757265737c767c77686f5369676e6564576861747c91810191909152602001919050565b6000613c0d6020836146ab565b7f556e61636365707461626c652077686f5369676e65645768617420617272617991810191909152602001919050565b6000613c4a6018836146ab565b7f4f7574636f6d65206368616e676520666f7262696464656e000000000000000091810191909152602001919050565b6000613c87601c836146ab565b7f737461747573284368616e6e656c4461746129213d73746f726167650000000091810191909152602001919050565b6000613cc46018836146ab565b7f61707044617461206368616e676520666f7262696464656e000000000000000091810191909152602001919050565b6000613d01601d836146ab565b7f496e76616c6964207369676e617475726573202f2021697346696e616c00000091810191909152602001919050565b6000613d3e601f836146ab565b7f4465706f73697420746f2065787465726e616c2064657374696e6174696f6e0091810191909152602001919050565b6000613d7b6016836146ab565b7f6c6172676573745475726e4e756d20746f6f206c6f770000000000000000000091810191909152602001919050565b6000613db86016836146ab565b7f4368616e6e656c206e6f742066696e616c697a65642e0000000000000000000091810191909152602001919050565b6000613df4818361133c565b01919050565b6000613e076017836146ab565b7f4f7574636f6d65206368616e676520766572626f74656e00000000000000000091810191909152602001919050565b6000613e44601e836146ab565b7f7c77686f5369676e6564576861747c213d6e5061727469636970616e7473000091810191909152602001919050565b6000613e81601b836146ab565b7f686f6c64696e677320616c72656164792073756666696369656e74000000000091810191909152602001919050565b6000613ebe601f836146ab565b7f496e636f7272656374206d73672e76616c756520666f72206465706f7369740091810191909152602001919050565b6000613efb6012836146ab565b7f697346696e616c20726574726f6772616465000000000000000000000000000091810191909152602001919050565b6000613f38601d836146ab565b7f436f756c64206e6f7420726566756e64206578636573732066756e647300000091810191909152602001919050565b80516000906080840190613f7c85826136ad565b506020830151613f8f60208601826136ad565b506040830151613fa26040860182614105565b506060830151848203606086015261178f82826136c7565b805160009060a0840190613fce85826136ad565b5060208301518482036020860152613fe68282613383565b9150506040830151613ffb60408601826140fc565b50606083015161400e606086018261337a565b5060808301516127ee60808601826140fc565b805161402d8382614105565b50602081015161404060208401826136ad565b5060408101516116b060408401826136ad565b80516000906060840190614067858261337a565b506020830151848203602086015261407f82826136c7565b9150506040830151848203604086015261178f8282613425565b80516080808452600091908401906140b1828261353b565b915050602083015184820360208601526140cb82826136c7565b91505060408301516140e060408601826140fc565b5060608301516127ee60608601826136a4565b613374816146c4565b613374816146d0565b613374816146db565b6000614119826137b6565b915061412582846136b6565b50602001919050565b600061115b82613de8565b60608101614147828661336b565b614154602083018561337a565b610fdd60408301846136ad565b6040810161416f828561337a565b610bbf60208301846136ad565b6060810161418a828661337a565b61415460208301856136ad565b608080825281016141a88187613490565b90506141b760208301866136a4565b81810360408301526141c98185613490565b905061178f60608301846136ad565b60208082528101611158818461359a565b6020810161115b82846136a4565b6020810161115b82846136ad565b60a0810161421382886136ad565b818103602083015261422581876136c7565b90508181036040830152614239818661359a565b905061424860608301856140fc565b61425560808301846136a4565b9695505050505050565b6040810161426d82846136ad565b818103602083015261115881613a55565b6080810161428c82876136ad565b6142996020830186614105565b6142a660408301856136ad565b61178f60608301846136ad565b6020808252810161115b816136ff565b6020808252810161115b8161373c565b6020808252810161115b81613779565b6020808252810161115b816137f3565b6020808252810161115b81613830565b6020808252810161115b8161386d565b6020808252810161115b816138aa565b6020808252810161115b816138e7565b6020808252810161115b81613924565b6020808252810161115b81613961565b6020808252810161115b8161399e565b6020808252810161115b816139db565b6020808252810161115b81613a18565b6020808252810161115b81613a92565b6020808252810161115b81613acf565b6020808252810161115b81613b0c565b6020808252810161115b81613b49565b6020808252810161115b81613b86565b6020808252810161115b81613bc3565b6020808252810161115b81613c00565b6020808252810161115b81613c3d565b6020808252810161115b81613c7a565b6020808252810161115b81613cb7565b6020808252810161115b81613cf4565b6020808252810161115b81613d31565b6020808252810161115b81613d6e565b6020808252810161115b81613dab565b6020808252810161115b81613dfa565b6020808252810161115b81613e37565b6020808252810161115b81613e74565b6020808252810161115b81613eb1565b6020808252810161115b81613eee565b6020808252810161115b81613f2b565b606080825281016144d48186614099565b905081810360208301526144e88185614099565b9050610fdd60408301846136ad565b60a0810161450582886136ad565b818103602083015261451781876133d9565b905061452660408301866140fc565b614533606083018561337a565b61425560808301846140fc565b6040810161416f82856136ad565b6020810161115b82846140fc565b60e0810161456a828a6140fc565b61457760208301896140fc565b61458460408301886136a4565b81810360608301526145968187613fba565b905081810360808301526145aa81866135f9565b905081810360a08301526145be81856134ef565b905081810360c08301526145d28184613658565b9998505050505050505050565b606081016145ed82866140fc565b6145fa60208301856140fc565b610fdd60408301846140f3565b60405181810167ffffffffffffffff811182821017156146295761462961472a565b604052919050565b600067ffffffffffffffff82111561464b5761464b61472a565b5060209081020190565b600067ffffffffffffffff82111561466f5761466f61472a565b5060200290565b600067ffffffffffffffff8211156146905761469061472a565b506020601f91909101601f19160190565b60200190565b5190565b90815260200190565b600061115b826146c4565b151590565b6001600160a01b031690565b65ffffffffffff1690565b60ff1690565b600061115b82600061115b826146b4565b82818337506000910152565b60005b83811015614719578181015183820152602001614701565b838111156117f25750506000910152565bfe5b601f01601f191690565b61473f816146b4565b811461172757600080fd5b61473f816146bf565b61473f81612218565b61473f816146d0565b61473f816146db56fea2646970667358221220425abb0653ace59485f083465524f6c6478bbd67d0861de987907138d9ecc10164736f6c63430007060033",
  "deployedBytecode": "0x6080604052600436106100e85760003560e01c806366d1b8a21161008a578063af69c9d711610059578063af69c9d714610279578063be5c2a3114610299578063c36b7e4e146102b9578063c7df14e2146102d9576100e8565b806366d1b8a2146101ec57806372c7f16d1461020c578063800399821461022c5780638bf6ed391461024c576100e8565b80632fb1d270116100c65780632fb1d270146101755780633033730e14610188578063552cfa50146101a8578063564b81ef146101d7576100e8565b806311e9f178146100ed578063166e56cd14610126578063180f6ff014610153575b600080fd5b3480156100f957600080fd5b5061010d610108366004613197565b6102f9565b60405161011d9493929190614197565b60405180910390f35b34801561013257600080fd5b50610146610141366004612d78565b610649565b60405161011d91906141f7565b34801561015f57600080fd5b5061017361016e3660046130d3565b610666565b005b610173610183366004612db0565b61068f565b34801561019457600080fd5b506101736101a336600461325e565b610937565b3480156101b457600080fd5b506101c86101c3366004612e61565b6109b7565b60405161011d939291906145df565b3480156101e357600080fd5b506101466109d2565b3480156101f857600080fd5b50610173610207366004613002565b6109d6565b34801561021857600080fd5b50610173610227366004612f51565b610b44565b34801561023857600080fd5b506101736102473660046130d3565b610ba2565b34801561025857600080fd5b5061026c610267366004613206565b610baf565b60405161011d91906141e9565b34801561028557600080fd5b50610173610294366004612e7e565b610bc6565b3480156102a557600080fd5b5061026c6102b43660046132f2565b610f60565b3480156102c557600080fd5b506101736102d4366004612ee0565b610fe5565b3480156102e557600080fd5b506101466102f4366004612e61565b611135565b606060006060600080855111610310578551610313565b84515b67ffffffffffffffff8111801561032957600080fd5b5060405190808252806020026020018201604052801561036357816020015b61035061242d565b8152602001906001900390816103485790505b50915060009050855167ffffffffffffffff8111801561038257600080fd5b506040519080825280602002602001820160405280156103bc57816020015b6103a961242d565b8152602001906001900390816103a15790505b50935060019250866000805b885181101561063d578881815181106103dd57fe5b6020026020010151600001518782815181106103f557fe5b6020026020010151600001818152505088818151811061041157fe5b60200260200101516040015187828151811061042957fe5b60200260200101516040019060ff16908160ff168152505088818151811061044d57fe5b60200260200101516060015187828151811061046557fe5b60200260200101516060018190525060006104978a838151811061048557fe5b60200260200101516020015185611147565b90508851600014806104c657508851831080156104c65750818984815181106104bc57fe5b6020026020010151145b156105d857600260ff168a84815181106104dc57fe5b60200260200101516040015160ff1614156105125760405162461bcd60e51b815260040161050990614383565b60405180910390fd5b808a838151811061051f57fe5b6020026020010151602001510388838151811061053857fe5b6020026020010151602001818152505060405180608001604052808b848151811061055f57fe5b60200260200101516000015181526020018281526020018b848151811061058257fe5b60200260200101516040015160ff1681526020018b84815181106105a257fe5b6020026020010151606001518152508684815181106105bd57fe5b6020026020010181905250808501945082600101925061060d565b8982815181106105e457fe5b6020026020010151602001518883815181106105fc57fe5b602002602001015160200181815250505b87828151811061061957fe5b60200260200101516020015160001461063157600096505b909203916001016103c8565b50505093509350935093565b600160209081526000928352604080842090915290825290205481565b60006106758686868686611161565b85519091506106879082906000610bc6565b505050505050565b61069883611335565b156106b55760405162461bcd60e51b815260040161050990614433565b6001600160a01b0384166000908152600160209081526040808320868452909152812054838110156106f95760405162461bcd60e51b8152600401610509906142c3565b6107038484611341565b81106107215760405162461bcd60e51b815260040161050990614483565b6107358161072f8686611341565b9061139b565b91506001600160a01b038616610769578234146107645760405162461bcd60e51b815260040161050990614493565b610820565b6040517f23b872dd0000000000000000000000000000000000000000000000000000000081526001600160a01b038716906323b872dd906107b290339030908790600401614139565b602060405180830381600087803b1580156107cc57600080fd5b505af11580156107e0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108049190612e44565b6108205760405162461bcd60e51b8152600401610509906143c3565b600061082c8284611341565b6001600160a01b03881660009081526001602090815260408083208a8452909152908190208290555190915086907f2dcdaad87b561ba5a69835009b4c53ef9d3c41ca6cc9574049187659d6c6a7159061088b908a908790869061417c565b60405180910390a26001600160a01b03871661092e5760006108ad858561139b565b90506000336001600160a01b0316826040516108c89061412e565b60006040518083038185875af1925050503d8060008114610905576040519150601f19603f3d011682016040523d82523d6000602084013e61090a565b606091505b505090508061092b5760405162461bcd60e51b8152600401610509906144b3565b50505b50505050505050565b6000806000610949888589888a6113f8565b925092509250600080600061097684878d8151811061096457fe5b602002602001015160400151896102f9565b9350935050925061098d8b868c8b8a888a88611476565b6109aa868c8151811061099c57fe5b602002602001015183611534565b5050505050505050505050565b60008060006109c58461156c565b9196909550909350915050565b4690565b6109ea856020015151855185518551610f60565b5060006109f68661158a565b90506000610a0386611600565b6040015190506000610a1483611627565b6002811115610a1f57fe5b1415610a3457610a2f8282611671565b610a63565b6001610a3f83611627565b6002811115610a4a57fe5b1415610a5a57610a2f82826116b5565b610a63826116f3565b6000610a7287848a898961172a565b9050610a8381896020015186611798565b827fbc93eb35d1e2104744f8837e55265ad2f79d1c3f0843e40e757505a1c9007f38838a608001514201610ab68b611600565b606001518c8c8c8c604051610ad1979695949392919061455c565b60405180910390a2610b2860405180608001604052808465ffffffffffff1681526020018a60800151420165ffffffffffff168152602001838152602001610b21610b1b8b611600565b516117f8565b9052611811565b6000938452602084905260409093209290925550505050505050565b610b58846020015151845184518451610f60565b506000610b648561158a565b90506000610b7185611600565b604001519050610b80826116f3565b610b8a82826116b5565b610b97858388878761172a565b50610687828261188b565b6106878585858585611161565b6000610bbc848484611912565b90505b9392505050565b610bcf836119ed565b610be281610bdc846117f8565b85611a20565b815160019060009067ffffffffffffffff81118015610c0057600080fd5b50604051908082528060200260200182016040528015610c3a57816020015b610c27612453565b815260200190600190039081610c1f5790505b5090506000845167ffffffffffffffff81118015610c5757600080fd5b50604051908082528060200260200182016040528015610c81578160200160208202803683370190505b5090506000855167ffffffffffffffff81118015610c9e57600080fd5b50604051908082528060200260200182016040528015610cc8578160200160208202803683370190505b50905060005b8651811015610e63576000878281518110610ce557fe5b602002602001015190506000816040015190506000898481518110610d0657fe5b602002602001015160000151905060016000826001600160a01b03166001600160a01b0316815260200190815260200160002060008c815260200190815260200160002054868581518110610d5757fe5b602002602001018181525050600080600080610dc98a8981518110610d7857fe5b602002602001015187600067ffffffffffffffff81118015610d9957600080fd5b50604051908082528060200260200182016040528015610dc3578160200160208202803683370190505b506102f9565b935093509350935082610ddb5760009b505b80898981518110610de857fe5b602002602001018181525050838e8981518110610e0157fe5b6020026020010151604001819052506040518060600160405280866001600160a01b0316815260200188602001518152602001838152508b8981518110610e4457fe5b6020026020010181905250505050505050508080600101915050610cce565b5060005b8651811015610f29576000878281518110610e7e57fe5b6020026020010151600001519050828281518110610e9857fe5b6020908102919091018101516001600160a01b03831660009081526001835260408082208d8352909352919091208054919091039055835189907fb3917fd12b23b8d48703d554ab284c5b1912bb5c67e710c7534a56c130637679908490879082908110610f0257fe5b6020026020010151604051610f18929190614540565b60405180910390a250600101610e67565b508315610f4457600087815260208190526040812055610f57565b610f578786610f52896117f8565b611a69565b61092e83611acf565b6000838510158015610f725750600084115b610f8e5760405162461bcd60e51b815260040161050990614363565b8483148015610f9c57508482145b610fb85760405162461bcd60e51b8152600401610509906143d3565b60ff851115610fd95760405162461bcd60e51b815260040161050990614373565b5060015b949350505050565b6000610ff08461158a565b9050600080610ffe8361156c565b50865160208101519051929450909250600091611029918691868a865b602002015160600151611aff565b60208781015190810151905191925060009161104e9187916001888101908c9061101b565b90506110a360405180608001604052808665ffffffffffff1681526020018565ffffffffffff16815260200184815260200161109b8a60006002811061109057fe5b6020020151516117f8565b905286611b3b565b6020880151805165ffffffffffff6001870116816110bd57fe5b06815181106110c857fe5b60200260200101516001600160a01b03166110e38288611b4e565b6001600160a01b0316146111095760405162461bcd60e51b8152600401610509906143a3565b61111d886020015151888a60600151611912565b5061112b858560010161188b565b5050505050505050565b60006020819052908152604090205481565b60008183116111565782611158565b815b90505b92915050565b600061116c8661158a565b9050611177816116f3565b61118d8660200151518560ff1684518651610f60565b508360ff16856040015160010165ffffffffffff1610156111c05760405162461bcd60e51b815260040161050990614443565b60008460ff1667ffffffffffffffff811180156111dc57600080fd5b50604051908082528060200260200182016040528015611206578160200160208202803683370190505b50905060005b8560ff168165ffffffffffff16101561126a5761124383886020015189600001518960ff16856001018c6040015101036001611aff565b828265ffffffffffff168151811061125757fe5b602090810291909101015260010161120c565b5061128086604001518860200151838688611c00565b61129c5760405162461bcd60e51b815260040161050990614423565b6112dd6040518060800160405280600065ffffffffffff1681526020014265ffffffffffff1681526020016000801b8152602001610b2189600001516117f8565b60008084815260200190815260200160002081905550817f4f465027a3d06ea73dd12be0f5c5fc0a34e21f19d6eaed4834a7a944edabc90142604051611323919061454e565b60405180910390a25095945050505050565b60a081901c155b919050565b600082820183811015611158576040805162461bcd60e51b815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b6000828211156113f2576040805162461bcd60e51b815260206004820152601e60248201527f536166654d6174683a207375627472616374696f6e206f766572666c6f770000604482015290519081900360640190fd5b50900390565b606060008061140687611cd6565b61140f866119ed565b61142185858051906020012088611a20565b61142a84611d35565b925082888151811061143857fe5b602090810291909101810151516001600160a01b03811660009081526001835260408082209982529890925296902054929895975091955050505050565b6001600160a01b03871660009081526001602090815260408083208984529091529020805482900390558351839085908a9081106114b057fe5b6020026020010151604001819052506114f08686866040516020016114d591906141d8565b60405160208183030381529060405280519060200120611a69565b857fb3917fd12b23b8d48703d554ab284c5b1912bb5c67e710c7534a56c1306376798984604051611522929190614540565b60405180910390a25050505050505050565b611568604051806060016040528084600001516001600160a01b031681526020018460200151815260200183815250611d4b565b5050565b60009081526020819052604090205460d081901c9160a082901c9190565b60006115946109d2565b8251146115b35760405162461bcd60e51b8152600401610509906142d3565b6115bb6109d2565b82602001518360400151846060015185608001516040516020016115e39594939291906144f7565b604051602081830303815290604052805190602001209050919050565b61160861247d565b8160018351038151811061161857fe5b60200260200101519050919050565b6000806116338361156c565b5091505065ffffffffffff811661164e57600091505061133c565b428165ffffffffffff161161166757600291505061133c565b600191505061133c565b600061167c8361156c565b505090508065ffffffffffff168265ffffffffffff1610156116b05760405162461bcd60e51b8152600401610509906142f3565b505050565b60006116c08361156c565b505090508065ffffffffffff168265ffffffffffff16116116b05760405162461bcd60e51b8152600401610509906142b3565b60026116fe82611627565b600281111561170957fe5b14156117275760405162461bcd60e51b8152600401610509906142e3565b50565b600080611738878787611df7565b905061175761174688611600565b604001518660200151838787611c00565b6117735760405162461bcd60e51b815260040161050990614353565b8060018251038151811061178357fe5b60200260200101519150505b95945050505050565b60006117ca846040516020016117ae919061425f565b6040516020818303038152906040528051906020012083611b4e565b90506117d68184611f85565b6117f25760405162461bcd60e51b815260040161050990614333565b50505050565b600061180382611fdb565b805190602001209050919050565b805160208201516040830151606084015160009360d01b7fffffffffffff00000000000000000000000000000000000000000000000000001660a093841b79ffffffffffff00000000000000000000000000000000000000001617929161187791612004565b6001600160a01b0316919091179392505050565b6040805160808101825265ffffffffffff8316815260006020820181905291810182905260608101919091526118c090611811565b60008084815260200190815260200160002081905550817f07da0a0674fb921e484018c8b81d80e292745e5d8ed134b580c8b9c631c5e9e082604051611906919061454e565b60405180910390a25050565b60008061191f8585612030565b9050600181600181111561192f57fe5b1415610fd957835160208501516040517f2934b2e40000000000000000000000000000000000000000000000000000000081526001600160a01b03861692632934b2e492611981928a906004016144c3565b60206040518083038186803b15801561199957600080fd5b505afa1580156119ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119d19190612e44565b610fd95760405162461bcd60e51b815260040161050990614303565b60026119f882611627565b6002811115611a0357fe5b146117275760405162461bcd60e51b815260040161050990614453565b6000611a2b8261156c565b92505050611a398484612004565b6001600160a01b0316816001600160a01b0316146117f25760405162461bcd60e51b8152600401610509906143b3565b600080611a758561156c565b50915091506000611ab560405180608001604052808565ffffffffffff1681526020018465ffffffffffff16815260200187815260200186815250611811565b600096875260208790526040909620959095555050505050565b60005b815181101561156857611af7828281518110611aea57fe5b6020026020010151611d4b565b600101611ad2565b60008585858585604051602001611b1a959493929190614205565b60405160208183030381529060405280519060200120905095945050505050565b611b458282612125565b6115688161215b565b60008083604051602001611b62919061410e565b604051602081830303815290604052805190602001209050600060018285600001518660200151876040015160405160008152602001604052604051611bab949392919061427e565b6020604051602081039080840390855afa158015611bcd573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b038116610fdd5760405162461bcd60e51b815260040161050990614393565b8351835160009190611c148489848461218e565b611c305760405162461bcd60e51b8152600401610509906143e3565b60005b82811015611cc7576000611c8388878481518110611c4d57fe5b602002602001015160ff1681518110611c6257fe5b6020026020010151888481518110611c7657fe5b6020026020010151611b4e565b9050888281518110611c9157fe5b60200260200101516001600160a01b0316816001600160a01b031614611cbe57600094505050505061178f565b50600101611c33565b50600198975050505050505050565b60005b815181600101101561156857818160010181518110611cf457fe5b6020026020010151828281518110611d0857fe5b602002602001015110611d2d5760405162461bcd60e51b815260040161050990614323565b600101611cd9565b60608180602001905181019061115b9190612e0f565b805160005b8260400151518110156116b057600083604001518281518110611d6f57fe5b6020026020010151600001519050600084604001518381518110611d8f57fe5b6020026020010151602001519050611da682611335565b15611dc357611dbe84611db884612218565b8361221b565b611ded565b6001600160a01b038416600090815260016020908152604080832085845290915290208054820190555b5050600101611d50565b60606000845167ffffffffffffffff81118015611e1357600080fd5b50604051908082528060200260200182016040528015611e3d578160200160208202803683370190505b50905060005b85518165ffffffffffff161015611f7c57611edd85878365ffffffffffff1681518110611e6c57fe5b602002602001015160200151888465ffffffffffff1681518110611e8c57fe5b602002602001015160000151898565ffffffffffff1681518110611eac57fe5b6020026020010151604001518a8665ffffffffffff1681518110611ecc57fe5b602002602001015160600151611aff565b828265ffffffffffff1681518110611ef157fe5b60200260200101818152505060018651038165ffffffffffff161015611f7457611f728460200151516040518060400160405280898565ffffffffffff1681518110611f3957fe5b60200260200101518152602001898560010165ffffffffffff1681518110611f5d57fe5b60200260200101518152508660600151611912565b505b600101611e43565b50949350505050565b6000805b8251811015611fd157828181518110611f9e57fe5b60200260200101516001600160a01b0316846001600160a01b03161415611fc957600191505061115b565b600101611f89565b5060009392505050565b606081604051602001611fee91906141d8565b6040516020818303038152906040529050919050565b604080516020808201949094528082019290925280518083038201815260609092019052805191012090565b60208101516060015160009015612077576120568260015b602002015151835151612344565b6120725760405162461bcd60e51b815260040161050990614463565b61211c565b8151606001511561209a5760405162461bcd60e51b8152600401610509906144a3565b6002830282600160200201516040015165ffffffffffff161015612114576120c3826001612048565b6120df5760405162461bcd60e51b8152600401610509906143f3565b6020828101518101518351909101516120f89190612360565b6120725760405162461bcd60e51b815260040161050990614413565b50600161115b565b50600092915050565b60008181526020819052604090205461213f9083906123c4565b6115685760405162461bcd60e51b815260040161050990614403565b600161216682611627565b600281111561217157fe5b146117275760405162461bcd60e51b815260040161050990614313565b6000828551146121b05760405162461bcd60e51b815260040161050990614473565b60005b8381101561220c57600084828765ffffffffffff16870103816121d257fe5b06905083818884815181106121e357fe5b602002602001015160ff1601600101101561220357600092505050610fdd565b506001016121b3565b50600195945050505050565b90565b6001600160a01b0383166122ab576000826001600160a01b0316826040516122429061412e565b60006040518083038185875af1925050503d806000811461227f576040519150601f19603f3d011682016040523d82523d6000602084013e612284565b606091505b50509050806122a55760405162461bcd60e51b815260040161050990614343565b506116b0565b6040517fa9059cbb0000000000000000000000000000000000000000000000000000000081526001600160a01b0384169063a9059cbb906122f29085908590600401614161565b602060405180830381600087803b15801561230c57600080fd5b505af1158015612320573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117f29190612e44565b600061115861235284611fdb565b61235b84611fdb565b6123d8565b81518151600091600191811480831461237c57600092506123ba565b600160208701838101602088015b6002848385100114156123b55780518351146123a95760009650600093505b6020928301920161238a565b505050505b5090949350505050565b6000816123d084611811565b149392505050565b8151815160009160019181148083146123f457600092506123ba565b600160208701838101602088015b6002848385100114156123b55780518351146124215760009650600093505b60209283019201612402565b604080516080810182526000808252602082018190529181019190915260608082015290565b604051806060016040528060006001600160a01b0316815260200160608152602001606081525090565b60405180608001604052806060815260200160608152602001600065ffffffffffff1681526020016000151581525090565b60006124c26124bd84614631565b614607565b905080838252602082019050828560208602850111156124e157600080fd5b60005b8581101561250b576124f68783612827565b835260209283019291909101906001016124e4565b5050509392505050565b60006125236124bd84614631565b8381529050602081018260005b8581101561250b578135850161254688826129e6565b8452506020928301929190910190600101612530565b600061256a6124bd84614631565b8381529050602081018260005b8581101561250b578151850161258d8882612a69565b8452506020928301929190910190600101612577565b60006125b16124bd84614631565b838152905060208101826060850281018610156125cd57600080fd5b60005b8581101561250b576125e28783612b74565b8352602090920191606091909101906001016125d0565b60006126076124bd84614631565b8381529050602081018260005b8581101561250b578135850161262a8882612bc1565b8452506020928301929190910190600101612614565b600061264e6124bd84614631565b8381529050602081018260005b8581101561250b57815185016126718882612c4b565b845250602092830192919091019060010161265b565b60006126956124bd84614655565b9050808260005b8581101561250b57813585016126b28882612cc8565b845250602092830192919091019060010161269c565b60006126d66124bd84614631565b8381529050602081018260005b8581101561250b57813585016126f98882612cc8565b84525060209283019291909101906001016126e3565b600061271d6124bd84614631565b9050808382526020820190508285602086028501111561273c57600080fd5b60005b8581101561250b576127518783612990565b8352602092830192919091019060010161273f565b60006127746124bd84614631565b9050808382526020820190508285602086028501111561279357600080fd5b60005b8581101561250b576127a88783612d62565b83526020928301929190910190600101612796565b60006127cb6124bd84614676565b9050828152602081018484840111156127e357600080fd5b6127ee8482856146f2565b509392505050565b60006128046124bd84614676565b90508281526020810184848401111561281c57600080fd5b6127ee8482856146fe565b803561115b81614736565b805161115b81614736565b600082601f83011261284d578081fd5b8135610fdd8482602086016124af565b600082601f83011261286d578081fd5b8135610fdd848260208601612515565b600082601f83011261288d578081fd5b8151610fdd84826020860161255c565b600082601f8301126128ad578081fd5b8135610fdd8482602086016125a3565b600082601f8301126128cd578081fd5b8135610fdd8482602086016125f9565b600082601f8301126128ed578081fd5b8151610fdd848260208601612640565b600082601f83011261290d578081fd5b6002610fdd848285612687565b600082601f83011261292a578081fd5b8135610fdd8482602086016126c8565b600082601f83011261294a578081fd5b8135610fdd84826020860161270f565b600082601f83011261296a578081fd5b8135610fdd848260208601612766565b803561115b8161474a565b805161115b8161474a565b803561115b81614753565b805161115b81614753565b600082601f8301126129b6578081fd5b8135610fdd8482602086016127bd565b600082601f8301126129d6578081fd5b8151610fdd8482602086016127f6565b6000608082840312156129f7578081fd5b612a016080614607565b90506000612a0f8484612990565b818301526020612a2185828601612990565b908301526040612a3385858301612d62565b90830152606083013567ffffffffffffffff811115612a50578182fd5b612a5c858286016129a6565b6060840152505092915050565b600060808284031215612a7a578081fd5b612a846080614607565b90506000612a92848461299b565b818301526020612aa48582860161299b565b908301526040612ab685858301612d6d565b90830152606083015167ffffffffffffffff811115612ad3578182fd5b612a5c858286016129c6565b600060a08284031215612af0578081fd5b612afa60a0614607565b90506000612b088484612990565b81830152602083013567ffffffffffffffff811115612b25578182fd5b612b318582860161283d565b602084015250506040612b4684828501612d57565b908201526060612b5884848301612827565b908201526080612b6a84848301612d57565b9082015292915050565b600060608284031215612b85578081fd5b612b8f6060614607565b90506000612b9d8484612d62565b908201526020612baf84848301612990565b908201526040612b6a84848301612990565b600060608284031215612bd2578081fd5b612bdc6060614607565b90506000612bea8484612827565b81830152602083013567ffffffffffffffff811115612c07578182fd5b612c13858286016129a6565b602084015250604083013567ffffffffffffffff811115612c32578182fd5b612c3e8582860161285d565b6040840152505092915050565b600060608284031215612c5c578081fd5b612c666060614607565b90506000612c748484612832565b81830152602083015167ffffffffffffffff811115612c91578182fd5b612c9d858286016129c6565b602084015250604083015167ffffffffffffffff811115612cbc578182fd5b612c3e8582860161287d565b600060808284031215612cd9578081fd5b612ce36080614607565b9050813567ffffffffffffffff811115612cfc57600080fd5b612d08848285016128bd565b825250602082013567ffffffffffffffff811115612d2557600080fd5b612d31848285016129a6565b6020830152506040612d4584828501612d57565b908201526060612b6a8484830161297a565b803561115b8161475c565b803561115b81614765565b805161115b81614765565b60008060408385031215612d8a578182fd5b612d9684838501612827565b91506020612da685828601612990565b9150509250929050565b60008060008060808587031215612dc5578182fd5b612dd186838701612827565b93506020612de187828801612990565b9350506040612df287828801612990565b9250506060612e0387828801612990565b91505092959194509250565b600060208284031215612e20578081fd5b8082015167ffffffffffffffff811115612e38578182fd5b610fdd848285016128dd565b600060208284031215612e55578081fd5b61115883828401612985565b600060208284031215612e72578081fd5b61115883828401612990565b600080600060608486031215612e92578081fd5b612e9e85828601612990565b9250602084013567ffffffffffffffff811115612eb9578182fd5b612ec5868287016128bd565b9250506040612ed686828701612990565b9150509250925092565b600080600060a08486031215612ef4578081fd5b8084013567ffffffffffffffff811115612f0c578182fd5b612f1886828701612adf565b935050602084013567ffffffffffffffff811115612f34578182fd5b612f40868287016128fd565b9250506040612ed686828701612b74565b60008060008060808587031215612f66578182fd5b8185013567ffffffffffffffff811115612f7e578283fd5b612f8a87828801612adf565b945050602085013567ffffffffffffffff811115612fa6578283fd5b612fb28782880161291a565b935050604085013567ffffffffffffffff811115612fce578283fd5b612fda8782880161289d565b925050606085013567ffffffffffffffff811115612ff6578182fd5b612e038782880161295a565b600080600080600060e08688031215613019578283fd5b8286013567ffffffffffffffff811115613031578384fd5b61303d88828901612adf565b955050602086013567ffffffffffffffff811115613059578384fd5b6130658882890161291a565b945050604086013567ffffffffffffffff811115613081578384fd5b61308d8882890161289d565b935050606086013567ffffffffffffffff8111156130a9578182fd5b6130b58882890161295a565b92505060806130c688828901612b74565b9150509295509295909350565b600080600080600060a086880312156130ea578283fd5b8286013567ffffffffffffffff811115613102578384fd5b61310e88828901612adf565b955050602086013567ffffffffffffffff81111561312a578384fd5b61313688828901612cc8565b945050604061314788828901612d62565b935050606086013567ffffffffffffffff811115613163578182fd5b61316f8882890161295a565b925050608086013567ffffffffffffffff81111561318b578182fd5b6130c68882890161289d565b6000806000606084860312156131ab578081fd5b6131b785828601612990565b9250602084013567ffffffffffffffff8111156131d2578182fd5b6131de8682870161285d565b925050604084013567ffffffffffffffff8111156131fa578182fd5b612ed68682870161293a565b60008060006060848603121561321a578081fd5b61322685828601612990565b9250602084013567ffffffffffffffff811115613241578182fd5b61324d868287016128fd565b9250506040612ed686828701612827565b600080600080600060a08688031215613275578283fd5b61328187848801612990565b9450602061329188828901612990565b945050604086013567ffffffffffffffff8111156132ad578384fd5b6132b9888289016129a6565b93505060606132ca88828901612990565b925050608086013567ffffffffffffffff8111156132e6578182fd5b6130c68882890161293a565b60008060008060808587031215613307578182fd5b612dd186838701612990565b600061331f838361337a565b505060200190565b60006111588383613f68565b600061333f8383614021565b505060600190565b60006111588383614053565b60006111588383614099565b600061331f8383614105565b613374816146e1565b82525050565b613374816146b4565b600061338e826146a7565b61339881856146ab565b93506133a3836146a1565b825b828110156133cf5781516133b98782613313565b9650506133c5826146a1565b91506001016133a5565b5093949350505050565b60006133e4826146a7565b6133ee81856146ab565b93506133f9836146a1565b825b828110156133cf57815161340f8782613313565b96505061341b826146a1565b91506001016133fb565b6000613430826146a7565b61343a81856146ab565b93508360208202850161344c856146a1565b845b8481101561348457838303885281516134678482613327565b935050613473826146a1565b60209890980197915060010161344e565b50909695505050505050565b600061349b826146a7565b6134a581856146ab565b9350836020820285016134b7856146a1565b845b8481101561348457838303885281516134d28482613327565b9350506134de826146a1565b6020989098019791506001016134b9565b60006134fa826146a7565b61350481856146ab565b935061350f836146a1565b825b828110156133cf5781516135258782613333565b965050613531826146a1565b9150600101613511565b6000613546826146a7565b61355081856146ab565b935083602082028501613562856146a1565b845b84811015613484578383038852815161357d8482613347565b935050613589826146a1565b602098909801979150600101613564565b60006135a5826146a7565b6135af81856146ab565b9350836020820285016135c1856146a1565b845b8481101561348457838303885281516135dc8482613347565b9350506135e8826146a1565b6020989098019791506001016135c3565b6000613604826146a7565b61360e81856146ab565b935083602082028501613620856146a1565b845b84811015613484578383038852815161363b8482613353565b935050613647826146a1565b602098909801979150600101613622565b6000613663826146a7565b61366d81856146ab565b9350613678836146a1565b825b828110156133cf57815161368e878261335f565b96505061369a826146a1565b915060010161367a565b613374816146bf565b61337481612218565b6133746136c282612218565b612218565b60006136d2826146a7565b6136dc81856146ab565b93506136ec8185602086016146fe565b6136f58161472c565b9093019392505050565b600061370c601c836146ab565b7f7475726e4e756d5265636f7264206e6f7420696e637265617365642e0000000091810191909152602001919050565b60006137496017836146ab565b7f686f6c64696e6773203c20657870656374656448656c6400000000000000000091810191909152602001919050565b60006137866011836146ab565b7f496e636f727265637420636861696e496400000000000000000000000000000091810191909152602001919050565b60006137c3601c8361133c565b7f19457468657265756d205369676e6564204d6573736167653a0a33320000000091810191909152601c01919050565b60006138006012836146ab565b7f4368616e6e656c2066696e616c697a65642e000000000000000000000000000091810191909152602001919050565b600061383d6018836146ab565b7f7475726e4e756d5265636f7264206465637265617365642e000000000000000091810191909152602001919050565b600061387a601f836146ab565b7f496e76616c696420466f7263654d6f7665417070205472616e736974696f6e0091810191909152602001919050565b60006138b76015836146ab565b7f4e6f206f6e676f696e67206368616c6c656e67652e000000000000000000000091810191909152602001919050565b60006138f46016836146ab565b7f496e6469636573206d75737420626520736f727465640000000000000000000091810191909152602001919050565b6000613931601f836146ab565b7f4368616c6c656e676572206973206e6f742061207061727469636970616e740091810191909152602001919050565b600061396e6016836146ab565b7f436f756c64206e6f74207472616e73666572204554480000000000000000000091810191909152602001919050565b60006139ab6012836146ab565b7f496e76616c6964207369676e617475726573000000000000000000000000000091810191909152602001919050565b60006139e8601d836146ab565b7f496e73756666696369656e74206f72206578636573732073746174657300000091810191909152602001919050565b6000613a256016836146ab565b7f546f6f206d616e79207061727469636970616e7473210000000000000000000091810191909152602001919050565b6000613a626009836146ab565b7f666f7263654d6f7665000000000000000000000000000000000000000000000091810191909152602001919050565b6000613a9f601b836146ab565b7f63616e6e6f74207472616e7366657220612067756172616e746565000000000091810191909152602001919050565b6000613adc6011836146ab565b7f496e76616c6964207369676e617475726500000000000000000000000000000091810191909152602001919050565b6000613b19601b836146ab565b7f5369676e6572206e6f7420617574686f72697a6564206d6f766572000000000091810191909152602001919050565b6000613b566015836146ab565b7f696e636f72726563742066696e6765727072696e74000000000000000000000091810191909152602001919050565b6000613b936018836146ab565b7f436f756c64206e6f74206465706f73697420455243323073000000000000000091810191909152602001919050565b6000613bd06020836146ab565b7f426164207c7369676e6174757265737c767c77686f5369676e6564576861747c91810191909152602001919050565b6000613c0d6020836146ab565b7f556e61636365707461626c652077686f5369676e65645768617420617272617991810191909152602001919050565b6000613c4a6018836146ab565b7f4f7574636f6d65206368616e676520666f7262696464656e000000000000000091810191909152602001919050565b6000613c87601c836146ab565b7f737461747573284368616e6e656c4461746129213d73746f726167650000000091810191909152602001919050565b6000613cc46018836146ab565b7f61707044617461206368616e676520666f7262696464656e000000000000000091810191909152602001919050565b6000613d01601d836146ab565b7f496e76616c6964207369676e617475726573202f2021697346696e616c00000091810191909152602001919050565b6000613d3e601f836146ab565b7f4465706f73697420746f2065787465726e616c2064657374696e6174696f6e0091810191909152602001919050565b6000613d7b6016836146ab565b7f6c6172676573745475726e4e756d20746f6f206c6f770000000000000000000091810191909152602001919050565b6000613db86016836146ab565b7f4368616e6e656c206e6f742066696e616c697a65642e0000000000000000000091810191909152602001919050565b6000613df4818361133c565b01919050565b6000613e076017836146ab565b7f4f7574636f6d65206368616e676520766572626f74656e00000000000000000091810191909152602001919050565b6000613e44601e836146ab565b7f7c77686f5369676e6564576861747c213d6e5061727469636970616e7473000091810191909152602001919050565b6000613e81601b836146ab565b7f686f6c64696e677320616c72656164792073756666696369656e74000000000091810191909152602001919050565b6000613ebe601f836146ab565b7f496e636f7272656374206d73672e76616c756520666f72206465706f7369740091810191909152602001919050565b6000613efb6012836146ab565b7f697346696e616c20726574726f6772616465000000000000000000000000000091810191909152602001919050565b6000613f38601d836146ab565b7f436f756c64206e6f7420726566756e64206578636573732066756e647300000091810191909152602001919050565b80516000906080840190613f7c85826136ad565b506020830151613f8f60208601826136ad565b506040830151613fa26040860182614105565b506060830151848203606086015261178f82826136c7565b805160009060a0840190613fce85826136ad565b5060208301518482036020860152613fe68282613383565b9150506040830151613ffb60408601826140fc565b50606083015161400e606086018261337a565b5060808301516127ee60808601826140fc565b805161402d8382614105565b50602081015161404060208401826136ad565b5060408101516116b060408401826136ad565b80516000906060840190614067858261337a565b506020830151848203602086015261407f82826136c7565b9150506040830151848203604086015261178f8282613425565b80516080808452600091908401906140b1828261353b565b915050602083015184820360208601526140cb82826136c7565b91505060408301516140e060408601826140fc565b5060608301516127ee60608601826136a4565b613374816146c4565b613374816146d0565b613374816146db565b6000614119826137b6565b915061412582846136b6565b50602001919050565b600061115b82613de8565b60608101614147828661336b565b614154602083018561337a565b610fdd60408301846136ad565b6040810161416f828561337a565b610bbf60208301846136ad565b6060810161418a828661337a565b61415460208301856136ad565b608080825281016141a88187613490565b90506141b760208301866136a4565b81810360408301526141c98185613490565b905061178f60608301846136ad565b60208082528101611158818461359a565b6020810161115b82846136a4565b6020810161115b82846136ad565b60a0810161421382886136ad565b818103602083015261422581876136c7565b90508181036040830152614239818661359a565b905061424860608301856140fc565b61425560808301846136a4565b9695505050505050565b6040810161426d82846136ad565b818103602083015261115881613a55565b6080810161428c82876136ad565b6142996020830186614105565b6142a660408301856136ad565b61178f60608301846136ad565b6020808252810161115b816136ff565b6020808252810161115b8161373c565b6020808252810161115b81613779565b6020808252810161115b816137f3565b6020808252810161115b81613830565b6020808252810161115b8161386d565b6020808252810161115b816138aa565b6020808252810161115b816138e7565b6020808252810161115b81613924565b6020808252810161115b81613961565b6020808252810161115b8161399e565b6020808252810161115b816139db565b6020808252810161115b81613a18565b6020808252810161115b81613a92565b6020808252810161115b81613acf565b6020808252810161115b81613b0c565b6020808252810161115b81613b49565b6020808252810161115b81613b86565b6020808252810161115b81613bc3565b6020808252810161115b81613c00565b6020808252810161115b81613c3d565b6020808252810161115b81613c7a565b6020808252810161115b81613cb7565b6020808252810161115b81613cf4565b6020808252810161115b81613d31565b6020808252810161115b81613d6e565b6020808252810161115b81613dab565b6020808252810161115b81613dfa565b6020808252810161115b81613e37565b6020808252810161115b81613e74565b6020808252810161115b81613eb1565b6020808252810161115b81613eee565b6020808252810161115b81613f2b565b606080825281016144d48186614099565b905081810360208301526144e88185614099565b9050610fdd60408301846136ad565b60a0810161450582886136ad565b818103602083015261451781876133d9565b905061452660408301866140fc565b614533606083018561337a565b61425560808301846140fc565b6040810161416f82856136ad565b6020810161115b82846140fc565b60e0810161456a828a6140fc565b61457760208301896140fc565b61458460408301886136a4565b81810360608301526145968187613fba565b905081810360808301526145aa81866135f9565b905081810360a08301526145be81856134ef565b905081810360c08301526145d28184613658565b9998505050505050505050565b606081016145ed82866140fc565b6145fa60208301856140fc565b610fdd60408301846140f3565b60405181810167ffffffffffffffff811182821017156146295761462961472a565b604052919050565b600067ffffffffffffffff82111561464b5761464b61472a565b5060209081020190565b600067ffffffffffffffff82111561466f5761466f61472a565b5060200290565b600067ffffffffffffffff8211156146905761469061472a565b506020601f91909101601f19160190565b60200190565b5190565b90815260200190565b600061115b826146c4565b151590565b6001600160a01b031690565b65ffffffffffff1690565b60ff1690565b600061115b82600061115b826146b4565b82818337506000910152565b60005b83811015614719578181015183820152602001614701565b838111156117f25750506000910152565bfe5b601f01601f191690565b61473f816146b4565b811461172757600080fd5b61473f816146bf565b61473f81612218565b61473f816146d0565b61473f816146db56fea2646970667358221220425abb0653ace59485f083465524f6c6478bbd67d0861de987907138d9ecc10164736f6c63430007060033",
  "devdoc": {
    "details": "The Adjudicator contract extends MultiAssetHolder and ForceMove",
    "kind": "dev",
    "methods": {
      "challenge((uint256,address[],uint48,address,uint48),((address,bytes,(bytes32,uint256,uint8,bytes)[])[],bytes,uint48,bool)[],(uint8,bytes32,bytes32)[],uint8[],(uint8,bytes32,bytes32))": {
        "details": "Registers a challenge against a state channel. A challenge will either prompt another participant into clearing the challenge (via one of the other methods), or cause the channel to finalize at a specific time.",
        "params": {
          "challengerSig": "The signature of a participant on the keccak256 of the abi.encode of (supportedStateHash, 'forceMove').",
          "fixedPart": "Data describing properties of the state channel that do not change with state updates.",
          "sigs": "An array of signatures that support the state with the `largestTurnNum`. There must be one for each participant, e.g.: [sig-from-p0, sig-from-p1, ...]",
          "variableParts": "An ordered array of structs, each decribing the properties of the state channel that may change with each state update. Length is from 1 to the number of participants (inclusive).",
          "whoSignedWhat": "An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`."
        }
      },
      "checkpoint((uint256,address[],uint48,address,uint48),((address,bytes,(bytes32,uint256,uint8,bytes)[])[],bytes,uint48,bool)[],(uint8,bytes32,bytes32)[],uint8[])": {
        "details": "Overwrites the `turnNumRecord` stored against a channel by providing a state with higher turn number, supported by a signature from each participant.",
        "params": {
          "fixedPart": "Data describing properties of the state channel that do not change with state updates.",
          "sigs": "An array of signatures that support the state with the `largestTurnNum`: one for each participant, in participant order (e.g. [sig of participant[0], sig of participant[1], ...]).",
          "variableParts": "An ordered array of structs, each decribing the properties of the state channel that may change with each state update.",
          "whoSignedWhat": "An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`."
        }
      },
      "conclude((uint256,address[],uint48,address,uint48),((address,bytes,(bytes32,uint256,uint8,bytes)[])[],bytes,uint48,bool),uint8,uint8[],(uint8,bytes32,bytes32)[])": {
        "details": "Finalizes a channel by providing a finalization proof. External wrapper for _conclude.",
        "params": {
          "fixedPart": "Data describing properties of the state channel that do not change with state updates.",
          "latestVariablePart": "Latest variable part in finalization proof. Must have the largest turnNum and the same appData and outcome as all other variable parts in finalization proof.",
          "numStates": "The number of states in the finalization proof.",
          "sigs": "An array of signatures that support the state with the `largestTurnNum`: one for each participant, in participant order (e.g. [sig of participant[0], sig of participant[1], ...]).",
          "whoSignedWhat": "An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`."
        }
      },
      "concludeAndTransferAllAssets((uint256,address[],uint48,address,uint48),((address,bytes,(bytes32,uint256,uint8,bytes)[])[],bytes,uint48,bool),uint8,uint8[],(uint8,bytes32,bytes32)[])": {
        "details": "Finalizes a channel by providing a finalization proof, and liquidates all assets for the channel.",
        "params": {
          "fixedPart": "Data describing properties of the state channel that do not change with state updates.",
          "latestVariablePart": "Latest variable part in finalization proof. Must have the largest turnNum and the same appData and outcome as all other variable parts in finalization proof.",
          "numStates": "The number of states in the finalization proof.",
          "sigs": "Array of signatures, one for each participant, in participant order (e.g. [sig of participant[0], sig of participant[1], ...]).",
          "whoSignedWhat": "An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`."
        }
      },
      "deposit(address,bytes32,uint256,uint256)": {
        "details": "Deposit ETH or erc20 tokens against a given channelId.",
        "params": {
          "amount": "The intended number of wei/tokens to be deposited.",
          "asset": "erc20 token address, or zero address to indicate ETH",
          "channelId": "ChannelId to be credited.",
          "expectedHeld": "The number of wei/tokens the depositor believes are _already_ escrowed against the channelId."
        }
      },
      "requireValidInput(uint256,uint256,uint256,uint256)": {
        "details": "Validates input for several external methods.",
        "params": {
          "numParticipants": "Length of the participants array",
          "numSigs": "Number of signatures submitted",
          "numStates": "Number of states submitted",
          "numWhoSignedWhats": "whoSignedWhat.length"
        }
      },
      "respond((uint256,address[],uint48,address,uint48),((address,bytes,(bytes32,uint256,uint8,bytes)[])[],bytes,uint48,bool)[2],(uint8,bytes32,bytes32))": {
        "details": "Repsonds to an ongoing challenge registered against a state channel.",
        "params": {
          "fixedPart": "Data describing properties of the state channel that do not change with state updates.",
          "sig": "The responder's signature on the `responseStateHash`.",
          "variablePartAB": "An pair of structs, each decribing the properties of the state channel that may change with each state update (for the challenge state and for the response state)."
        }
      },
      "transfer(uint256,bytes32,bytes,bytes32,uint256[])": {
        "details": "Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries.",
        "params": {
          "assetIndex": "Will be used to slice the outcome into a single asset outcome.",
          "fromChannelId": "Unique identifier for state channel to transfer funds *from*.",
          "indices": "Array with each entry denoting the index of a destination to transfer funds to. An empty array indicates \"all\".",
          "outcomeBytes": "The encoded Outcome of this state channel",
          "stateHash": "The hash of the state stored when the channel finalized."
        }
      },
      "transferAllAssets(bytes32,(address,bytes,(bytes32,uint256,uint8,bytes)[])[],bytes32)": {
        "details": "Liquidates all assets for the channel",
        "params": {
          "channelId": "Unique identifier for a state channel",
          "outcome": "An array of SingleAssetExit[] items.",
          "stateHash": "stored state hash for the channel"
        }
      },
      "unpackStatus(bytes32)": {
        "details": "Unpacks turnNumRecord, finalizesAt and fingerprint from the status of a particular channel.",
        "params": {
          "channelId": "Unique identifier for a state channel."
        },
        "returns": {
          "finalizesAt": "The unix timestamp when `channelId` will finalize.",
          "fingerprint": "The last 160 bits of kecca256(stateHash, outcomeHash)",
          "turnNumRecord": "A turnNum that (the adjudicator knows) is supported by a signature from each participant."
        }
      },
      "validTransition(uint256,((address,bytes,(bytes32,uint256,uint8,bytes)[])[],bytes,uint48,bool)[2],address)": {
        "details": "Check that the submitted pair of states form a valid transition (public wrapper for internal function _requireValidTransition)",
        "params": {
          "ab": "Variable parts of each of the pair of states",
          "appDefinition": "Address of deployed contract containing application-specific validTransition function.",
          "nParticipants": "Number of participants in the channel. transition"
        },
        "returns": {
          "_0": "true if the later state is a validTransition from its predecessor, reverts otherwise."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "challenge((uint256,address[],uint48,address,uint48),((address,bytes,(bytes32,uint256,uint8,bytes)[])[],bytes,uint48,bool)[],(uint8,bytes32,bytes32)[],uint8[],(uint8,bytes32,bytes32))": {
        "notice": "Registers a challenge against a state channel. A challenge will either prompt another participant into clearing the challenge (via one of the other methods), or cause the channel to finalize at a specific time."
      },
      "checkpoint((uint256,address[],uint48,address,uint48),((address,bytes,(bytes32,uint256,uint8,bytes)[])[],bytes,uint48,bool)[],(uint8,bytes32,bytes32)[],uint8[])": {
        "notice": "Overwrites the `turnNumRecord` stored against a channel by providing a state with higher turn number, supported by a signature from each participant."
      },
      "conclude((uint256,address[],uint48,address,uint48),((address,bytes,(bytes32,uint256,uint8,bytes)[])[],bytes,uint48,bool),uint8,uint8[],(uint8,bytes32,bytes32)[])": {
        "notice": "Finalizes a channel by providing a finalization proof. External wrapper for _conclude."
      },
      "concludeAndTransferAllAssets((uint256,address[],uint48,address,uint48),((address,bytes,(bytes32,uint256,uint8,bytes)[])[],bytes,uint48,bool),uint8,uint8[],(uint8,bytes32,bytes32)[])": {
        "notice": "Finalizes a channel by providing a finalization proof, and liquidates all assets for the channel."
      },
      "deposit(address,bytes32,uint256,uint256)": {
        "notice": "Deposit ETH or erc20 tokens against a given channelId."
      },
      "holdings(address,bytes32)": {
        "notice": "holdings[asset][channelId] is the amount of asset held against channel channelId. 0 address implies ETH"
      },
      "requireValidInput(uint256,uint256,uint256,uint256)": {
        "notice": "Validates input for several external methods."
      },
      "respond((uint256,address[],uint48,address,uint48),((address,bytes,(bytes32,uint256,uint8,bytes)[])[],bytes,uint48,bool)[2],(uint8,bytes32,bytes32))": {
        "notice": "Repsonds to an ongoing challenge registered against a state channel."
      },
      "transfer(uint256,bytes32,bytes,bytes32,uint256[])": {
        "notice": "Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries."
      },
      "transferAllAssets(bytes32,(address,bytes,(bytes32,uint256,uint8,bytes)[])[],bytes32)": {
        "notice": "Liquidates all assets for the channel"
      },
      "unpackStatus(bytes32)": {
        "notice": "Unpacks turnNumRecord, finalizesAt and fingerprint from the status of a particular channel."
      },
      "validTransition(uint256,((address,bytes,(bytes32,uint256,uint8,bytes)[])[],bytes,uint48,bool)[2],address)": {
        "notice": "Check that the submitted pair of states form a valid transition (public wrapper for internal function _requireValidTransition)"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 4460,
        "contract": "contracts/StateChannel/Adjudicator.sol:Adjudicator",
        "label": "statusOf",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_bytes32,t_bytes32)"
      },
      {
        "astId": 3568,
        "contract": "contracts/StateChannel/Adjudicator.sol:Adjudicator",
        "label": "holdings",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_mapping(t_bytes32,t_uint256))"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_mapping(t_address,t_mapping(t_bytes32,t_uint256))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(bytes32 => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_bytes32,t_uint256)"
      },
      "t_mapping(t_bytes32,t_bytes32)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => bytes32)",
        "numberOfBytes": "32",
        "value": "t_bytes32"
      },
      "t_mapping(t_bytes32,t_uint256)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}