{
  "language": "Solidity",
  "sources": {
    "contracts/CommitReveal/CommitRevealApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * Created on 2022-06-02 12:37\n * @summary: An abstract contract for implementing a ForceMove application with shared randomness\n * @author: Willem Olding (ChainSafe)\n */\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport '../StateChannel/interfaces/IForceMoveApp.sol';\nimport {ExitFormat as Outcome} from '@statechannels/exit-format/contracts/ExitFormat.sol';\n\nabstract contract CommitRevealApp is IForceMoveApp {\n\n    // player indices\n    uint8 constant A = 0;\n    uint8 constant B = 1;\n\n    // The phases of the protocol\n    enum Phase { A_COMMIT, B_COMMIT, A_REVEAL, B_REVEAL }\n\n    // Data that must be included in each reveal phase state update\n    struct Reveal {\n        uint8 move;\n        bytes32 seed;\n    }\n\n    // Application specific data for the ForceMove app\n    // This itself contains game specific data\n    struct AppData {\n        bytes32 preCommitA;\n        bytes32 preCommitB;\n\n        Reveal revealA;\n        Reveal revealB;\n\n        bytes gameState;\n    }\n\n\n\n    /**\n     * @dev Takes a game state and outcome and mutates it using a move from each player\n     *      collaboratively produced randomness\n     * @param gameState The prior game state to be mutated and returned\n     * @param outcome The prior outcome that can be mutated and returned\n     * @param moveA Move from player A\n     * @param moveB Move from player B\n     * @param randomSeed The combined random seed produced by the protocol \n     * @return The outcome resulting in a rebalance to the given player\n     */\n    function advanceState(\n        bytes memory gameState,\n        Outcome.SingleAssetExit[] memory outcome,\n        uint8 moveA,\n        uint8 moveB,\n        bytes32 randomSeed\n    ) virtual public pure returns (bytes memory, Outcome.SingleAssetExit[] memory, bool);\n\n    /**\n     * @dev Take an old outcome and update it to favour a given player\n     *       Assumes the outcome allocations can be indexed by the playerIndex\n     * @param outcome An outcome object to be rebalanced\n     * @param playerIndex Zero based index of the player to be assigned the favoured outcome\n     * @return The outcome resulting in a rebalance to the given player\n     */\n    function updateOutcomeFavourPlayer(\n        Outcome.SingleAssetExit[] memory outcome,\n        uint8 playerIndex\n    ) virtual public pure returns (Outcome.SingleAssetExit[] memory);\n\n\n    /**\n     * @notice Decodes the appData.\n     * @dev Decodes the appData.\n     * @param appDataBytes The abi.encode of an AppData struct describing the application-specific data.\n     * @return A AppData struct containing the application-specific data.\n     */\n    function _appData(bytes memory appDataBytes) internal pure returns (AppData memory) {\n        return abi.decode(appDataBytes, (AppData));\n    }\n\n    /**\n     * @notice Combines two pieces of randomness to produce a single random seed\n     * @dev Combines two pieces of randomness to produce a single random seed\n     * @param partSeedA A random value\n     * @param partSeedB A random value\n     * @return A random seed from the combined randomness\n     */\n    function _mergeSeeds(bytes32 partSeedA, bytes32 partSeedB) internal pure returns (bytes32) {\n        return keccak256(abi.encode(partSeedA, partSeedB));\n    }\n\n    // helper to do byte array comparison\n    // can replace with a more efficient version later\n    function _compareBytes(bytes memory a, bytes memory b) internal pure returns (bool) {\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n    }\n\n    // helper to do byte array comparison\n    function _compareReveals(Reveal memory a, Reveal memory b) internal pure returns (bool) {\n        return (keccak256(abi.encode((a))) == keccak256(abi.encode((b))));\n    }\n\n    // helper to do byte array comparison\n    function _compareOutcomes(Outcome.SingleAssetExit[] memory a, Outcome.SingleAssetExit[] memory b) internal pure returns (bool) {\n        return (keccak256(abi.encode((a))) == keccak256(abi.encode((b))));\n    }\n\n    /**\n     * @dev Get the current phase given the turn number\n     * @param turnNum The current sequence/turn number\n     * @return Phase\n     */\n    function _phase(uint48 turnNum) internal pure returns (Phase) {\n\n        // The first 4 turnNums (0,1,2,3) are used for the pre-fund and post-fund setup phase\n        // This function will be called at all with those turnNums.\n        // Coincidentally this is a multiple of the number of phases in CommitReveal so there \n        // is no need to adjust.\n        \n        // This conversion is safe as the modulo is always < 4\n        return Phase(turnNum % 4);\n    }\n\n    /**\n     * @dev Override of IForceMove validTransition for the randomness protocol\n     */\n    function validTransition(\n        VariablePart memory prev,\n        VariablePart memory next,\n        uint256 nParticipants\n    ) public pure override returns (bool) {\n        require(nParticipants == 2, \"Only two participant commit/reveal games are supported\");\n\n        // we are in the commit/reveal cycle of gameplay\n        Phase phase = _phase(next.turnNum);\n\n        AppData memory prevData = _appData(prev.appData);\n        AppData memory nextData = _appData(next.appData);\n\n        if        (phase == Phase.A_COMMIT) {\n            // no change constraints\n            require(_compareBytes(prevData.gameState, nextData.gameState), \"Cannot mutate the game state in [A commitment] move\");\n            // outcome\n            require(_compareOutcomes(next.outcome, updateOutcomeFavourPlayer(prev.outcome, A)));\n        } else if (phase == Phase.B_COMMIT) {\n            // no change constraints\n            require(_compareBytes(prevData.gameState, nextData.gameState), \"Cannot mutate the game state in [B commitment] move\");\n            require(prevData.preCommitA == nextData.preCommitA, \"Cannot mutate A's preCommit in [B commitment] move\");\n            // outcome\n            require(_compareOutcomes(next.outcome, updateOutcomeFavourPlayer(prev.outcome, B)));\n        } else if (phase == Phase.A_REVEAL) {\n            // no change constraints\n            require(_compareBytes(prevData.gameState, nextData.gameState), \"Cannot mutate the game state in [A reveal] move\");\n            // require(prevData.preCommitA == nextData.preCommitA, \"Cannot mutate A's preCommit in [A reveal] move\");\n            require(prevData.preCommitB == nextData.preCommitB, \"Cannot mutate B's preCommit in [A reveal] move\");\n            // reveal matches preCommit\n            require(prevData.preCommitA ==  keccak256(abi.encode(nextData.revealA)));\n            // outcome\n            require(_compareOutcomes(next.outcome, updateOutcomeFavourPlayer(prev.outcome, A)));\n        } else if (phase == Phase.B_REVEAL) {\n            // reveal matches preCommit\n            require(prevData.preCommitB == keccak256(abi.encode(nextData.revealB)));\n            // outcome\n            require(_compareOutcomes(next.outcome, updateOutcomeFavourPlayer(prev.outcome, B)));\n            // game state update is made correctly with respect to the committed moves and random seeds\n            bytes32 randomSeed = _mergeSeeds(nextData.revealA.seed, nextData.revealB.seed);\n            (bytes memory newState,, bool isFinal) = advanceState(prevData.gameState, prev.outcome, nextData.revealA.move, nextData.revealB.move, randomSeed);\n            require(\n                _compareBytes(\n                    newState,\n                    nextData.gameState\n                ), \"New state must be computed based on preCommit moves in [B reveal] move\"\n            );\n            // if the game state concluded this must be reflected in the variable part of the channel state\n            require(isFinal == next.isFinal);\n        }\n\n        return true;\n    }\n}\n"
    },
    "contracts/StateChannel/interfaces/IForceMoveApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {ExitFormat as Outcome} from '@statechannels/exit-format/contracts/ExitFormat.sol';\n\n/**\n * @dev The IForceMoveApp interface calls for its children to implement an application-specific validTransition function, defining the state machine of a ForceMove state channel DApp.\n */\ninterface IForceMoveApp {\n    struct VariablePart {\n        Outcome.SingleAssetExit[] outcome;\n        bytes appData;\n        uint48 turnNum;\n        bool isFinal;\n    }\n\n    /**\n     * @notice Encodes application-specific rules for a particular ForceMove-compliant state channel.\n     * @dev Encodes application-specific rules for a particular ForceMove-compliant state channel.\n     * @param a State being transitioned from.\n     * @param b State being transitioned to.\n     * @param nParticipants Number of participants in this state channel.\n     * @return true if the transition conforms to this application's rules, false otherwise\n     */\n    function validTransition(\n        VariablePart calldata a,\n        VariablePart calldata b,\n        uint256 nParticipants\n    ) external pure returns (bool);\n}\n"
    },
    "@statechannels/exit-format/contracts/ExitFormat.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\npragma experimental ABIEncoderV2;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface ERC20Interface {\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n\n// Ideally this would be imported from @connect/vector-withdraw-helpers\n// And the interface would match this one (note WithdrawData calldata wd has become bytes calldata cD)\ninterface WithdrawHelper {\n    function execute(bytes calldata cD, uint256 actualAmount) external;\n}\n\nlibrary ExitFormat {\n    // An Exit is an array of SingleAssetExit (one for each asset)\n    // Exit = SingleAssetExit[]\n\n    // A SingleAssetExit specifies\n    // * an asset address (0 implies the native asset of the chain: on mainnet, this is ETH)\n    // * custom metadata (optional field, can be zero bytes). This might specify how to transfer this particular asset (e.g. target an \"ERC20.transfer\"' method)\n    // * an allocations array\n    struct SingleAssetExit {\n        address asset;\n        bytes metadata;\n        Allocation[] allocations;\n    }\n\n    // allocations is an ordered array of Allocation.\n    // The ordering is important, and may express e.g. a priority order for the exit\n    // (which would make a material difference to the final state in the case of running out of gas or funds)\n    // Allocations = Allocation[]\n\n    enum AllocationType {simple, withdrawHelper, guarantee}\n\n    // An Allocation specifies\n    // * a destination, referring either to an ethereum address or an application-specific identifier\n    // * an amount of asset\n    // * an allocationType, which directs calling code on how to interpret the allocation\n    // * custom metadata (optional field, can be zero bytes). This can be used flexibly by different protocols.\n    struct Allocation {\n        bytes32 destination;\n        uint256 amount;\n        uint8 allocationType;\n        bytes metadata;\n    }\n\n    /**\n     * specifies the decoding format for metadata bytes fields\n     * received with the WithdrawHelper flag\n     */\n    struct WithdrawHelperMetaData {\n        address callTo;\n        bytes callData;\n    }\n\n    // We use underscore parentheses to denote an _encodedVariable_\n    function encodeExit(SingleAssetExit[] memory exit)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encode(exit);\n    }\n\n    function decodeExit(bytes memory _exit_)\n        internal\n        pure\n        returns (SingleAssetExit[] memory)\n    {\n        return abi.decode(_exit_, (SingleAssetExit[]));\n    }\n\n    function encodeAllocation(Allocation memory allocation)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encode(allocation);\n    }\n\n    function decodeAllocation(bytes memory _allocation_)\n        internal\n        pure\n        returns (Allocation memory)\n    {\n        return abi.decode(_allocation_, (Allocation));\n    }\n\n    function exitsEqual(\n        SingleAssetExit[] memory exitA,\n        SingleAssetExit[] memory exitB\n    ) internal pure returns (bool) {\n        return _bytesEqual(encodeExit(exitA), encodeExit(exitB));\n    }\n\n    /**\n     * @notice Executes an exit by paying out assets and calling external contracts\n     * @dev Executes an exit by paying out assets and calling external contracts\n     * @param exit The exit to be paid out.\n     */\n    function executeExit(ExitFormat.SingleAssetExit[] memory exit) internal {\n        for (uint256 assetIndex = 0; assetIndex < exit.length; assetIndex++) {\n            executeSingleAssetExit(exit[assetIndex]);\n        }\n    }\n\n    /**\n     * @notice Executes a single asset exit by paying out the asset and calling external contracts\n     * @dev Executes a single asset exit by paying out the asset and calling external contracts\n     * @param singleAssetExit The single asset exit to be paid out.\n     */\n    function executeSingleAssetExit(\n        ExitFormat.SingleAssetExit memory singleAssetExit\n    ) internal {\n        address asset = singleAssetExit.asset;\n        for (uint256 j = 0; j < singleAssetExit.allocations.length; j++) {\n            require(\n                _isAddress(singleAssetExit.allocations[j].destination),\n                \"Destination is not a zero-padded address\"\n            );\n            address payable destination =\n                payable(\n                    address(\n                        uint160(\n                            uint256(singleAssetExit.allocations[j].destination)\n                        )\n                    )\n                );\n            uint256 amount = singleAssetExit.allocations[j].amount;\n            if (asset == address(0)) {\n                (bool success, ) = destination.call{value: amount}(\"\"); //solhint-disable-line avoid-low-level-calls\n                require(success, \"Could not transfer ETH\");\n            } else {\n                // TODO support other token types via the singleAssetExit.metadata field\n                ERC20Interface(asset).transfer(destination, amount);\n            }\n            if (\n                singleAssetExit.allocations[j].allocationType ==\n                uint8(AllocationType.withdrawHelper)\n            ) {\n                WithdrawHelperMetaData memory wd =\n                    _parseWithdrawHelper(\n                        singleAssetExit.allocations[j].metadata\n                    );\n                WithdrawHelper(wd.callTo).execute(wd.callData, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Checks whether given destination is a valid Ethereum address\n     * @dev Checks whether given destination is a valid Ethereum address\n     * @param destination the destination to be checked\n     */\n    function _isAddress(bytes32 destination) internal pure returns (bool) {\n        return uint96(bytes12(destination)) == 0;\n    }\n\n    /**\n     * @notice Returns a callTo address and callData from metadata bytes\n     * @dev Returns a callTo address and callData from metadata bytes\n     */\n    function _parseWithdrawHelper(bytes memory metadata)\n        internal\n        pure\n        returns (WithdrawHelperMetaData memory)\n    {\n        return abi.decode(metadata, (WithdrawHelperMetaData));\n    }\n\n    /**\n     * @notice Check for equality of two byte strings\n     * @dev Check for equality of two byte strings\n     * @param _preBytes One bytes string\n     * @param _postBytes The other bytes string\n     * @return true if the bytes are identical, false otherwise.\n     */\n    function _bytesEqual(bytes memory _preBytes, bytes memory _postBytes)\n        internal\n        pure\n        returns (bool)\n    {\n        // copied from https://www.npmjs.com/package/solidity-bytes-utils/v/0.1.1\n        bool success = true;\n\n        /* solhint-disable no-inline-assembly */\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n                case 1 {\n                    // cb is a circuit breaker in the for loop since there's\n                    //  no said feature for inline assembly loops\n                    // cb = 1 - don't breaker\n                    // cb = 0 - break\n                    let cb := 1\n\n                    let mc := add(_preBytes, 0x20)\n                    let end := add(mc, length)\n\n                    for {\n                        let cc := add(_postBytes, 0x20)\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                    } eq(add(lt(mc, end), cb), 2) {\n                        mc := add(mc, 0x20)\n                        cc := add(cc, 0x20)\n                    } {\n                        // if any of these checks fails then arrays are not equal\n                        if iszero(eq(mload(mc), mload(cc))) {\n                            // unsuccess:\n                            success := 0\n                            cb := 0\n                        }\n                    }\n                }\n                default {\n                    // unsuccess:\n                    success := 0\n                }\n        }\n        /* solhint-disable no-inline-assembly */\n\n        return success;\n    }\n}\n"
    },
    "contracts/Toshimon/ToshimonStateTransition.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * Created on 2022-06-23 12:37\n * @summary: The state transition function that captures all the rules of the Toshimon battle game\n * @author: Willem Olding (ChainSafe)\n */\n pragma solidity 0.7.6;\n pragma experimental ABIEncoderV2;\n\n import \"@openzeppelin/contracts/math/SafeMath.sol\";\n import '../CommitReveal/CommitRevealApp.sol';\n import { ToshimonState as TM } from './ToshimonState.sol';\n import './interfaces/IMove.sol';\n import './interfaces/IItem.sol';\n\n\n contract ToshimonStateTransition is CommitRevealApp {\n\n    function advanceState(\n        bytes memory _gameState_,\n        Outcome.SingleAssetExit[] memory outcome,\n        uint8 moveA,\n        uint8 moveB,\n        bytes32 randomSeed\n        ) public pure override returns (bytes memory, Outcome.SingleAssetExit[] memory, bool) {\n        TM.GameState memory gameState = abi.decode(_gameState_, (TM.GameState));\n        (TM.GameState memory newState,  Outcome.SingleAssetExit[] memory newOutcome, bool isFinal) = advanceStateTyped(gameState, outcome, moveA, moveB, randomSeed);\n        return (abi.encode(newState), newOutcome, isFinal);\n    }\n\n    function advanceStateTyped(\n        TM.GameState memory gameState,\n        Outcome.SingleAssetExit[] memory outcome,\n        uint8 moveA,\n        uint8 moveB,\n        bytes32 randomSeed\n        ) public pure returns (TM.GameState memory, Outcome.SingleAssetExit[] memory, bool) {\n\n\n        // if either player is unconcious then no more moves can be made\n        // and the game is over. No further state updates possible.\n        if (_is_unconcious(gameState.players[A]) || _is_unconcious(gameState.players[B])) {\n            return (gameState, outcome, true);\n        }\n        \n        // first up resolve any switch monster actions\n        // These occur first and order between players doesn't matter\n        if ( _isSwapAction(moveA) ) {\n            gameState.players[A].activeMonsterIndex = moveA - 4;\n        }\n        if ( _isSwapAction(moveB) ) {\n            gameState.players[A].activeMonsterIndex = moveB - 4;\n        }\n\n        // next up resolve items. These can only be applied to the active monster\n        // and they are resolved before attacks so again order doesn't matter here\n        if ( _isItemAction(moveA) ) {\n            gameState = _useItem(gameState, moveA - 9, A, randomSeed);\n        }\n        if ( _isItemAction(moveB) ) {\n            gameState = _useItem(gameState, moveA - 9, B, randomSeed);\n        }        \n\n        // next up resolve attacks. Speed should be used to resolve\n        // if both players are attackign but here A always goes first\n        // for demo purposes\n        if ( _isMoveAction(moveA) ) {\n            gameState = _makeMove(gameState, moveA,  A, randomSeed);\n        }\n        if ( _isMoveAction(moveB) ) {\n            gameState = _makeMove(gameState, moveB,  B, randomSeed);\n        }\n\n        return (gameState, outcome, true);\n\n    }\n\n    // For incentive reasons it needs to ensure that each time a player makes\n    // a state update they set themselves as the winning player\n    // unless the game forces otherwise via a conclusion\n    // \n    // The entire balance is reallocated to the winning player index by this function\n    // \n    // This assumes the outcome is ordered according to the players.\n    function updateOutcomeFavourPlayer(\n        Outcome.SingleAssetExit[] memory outcome,\n        uint8 playerIndex\n        ) override public pure returns (Outcome.SingleAssetExit[] memory) {\n        Outcome.SingleAssetExit memory wagerAssetExit = outcome[0];\n        uint256 total = wagerAssetExit.allocations[0].amount + wagerAssetExit.allocations[1].amount;\n\n        outcome[0].allocations[playerIndex].amount = total;\n        outcome[0].allocations[~playerIndex].amount = 0;\n\n        return (outcome);\n    }\n\n    // A player is unconcious if all their monsters have HP == 0\n    function _is_unconcious(TM.PlayerState memory playerState) pure internal returns (bool) {\n        bool unconcious = true;\n        for (uint8 i = 0; i < playerState.monsters.length; i++) {\n            if (playerState.monsters[i].stats.hp > 0) {\n                unconcious = false;\n            }\n        }\n        return (unconcious);\n    }\n\n    function _isItemAction(uint8 move) pure internal returns (bool) {\n        return (move >=9 && move <=13);\n    }\n\n    function _isSwapAction(uint8 move) pure internal returns (bool) {\n        return (move >=4 && move <=8);\n    }\n\n    function _isMoveAction(uint8 move) pure internal returns (bool) {\n        return (move < 4);\n    }\n\n    function _makeMove(TM.GameState memory gameState, uint8 moveIndex, uint8 mover, bytes32 randomSeed) pure internal returns (TM.GameState memory) {\n        TM.MonsterCard memory attacker = _getActiveMonster(gameState.players[mover]);\n        TM.MonsterCard memory defender = _getActiveMonster(gameState.players[~mover]);\n\n        // bail if attacker is unconcious or no PP available\n        if (attacker.stats.hp == 0) {\n            return gameState;\n        }\n        if (attacker.stats.pp[moveIndex] == 0) {\n            return gameState;\n        }        \n\n        // reduce the PP of the attacker on that move\n        attacker.stats.pp[moveIndex] -= 1;\n\n        // apply move\n        gameState = IMove(attacker.moves[moveIndex]).applyMove(gameState, mover, randomSeed);\n\n        return gameState;\n\n    }\n\n    function _useItem(TM.GameState memory gameState, uint8 itemIndex, uint8 mover, bytes32 randomSeed) pure internal returns (TM.GameState memory) {\n        TM.PlayerState memory user = gameState.players[mover];\n\n        // mark the item as used\n        user.items[itemIndex].used = true;\n\n        // apply the item\n        gameState = IItem(user.items[itemIndex].definition).applyItem(gameState, mover, user.activeMonsterIndex, randomSeed);\n\n        return gameState;\n\n    }\n\n    function _getActiveMonster(TM.PlayerState memory playerState) pure internal returns (TM.MonsterCard memory) {\n        return (playerState.monsters[playerState.activeMonsterIndex]);\n    }\n\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/Toshimon/ToshimonState.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n/**\n * Created on 2022-06-06\n * @summary: Types for representing the toshimon game state\n * @author: Willem Olding (ChainSafe)\n */\n\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nlibrary ToshimonState {\n\n\tstruct GameState {\n\t\tPlayerState[2] players;\n\t}\n\n\tstruct PlayerState {\n\t\tMonsterCard[] monsters;\n\t\tItemCard[] items;\n\t\tuint8 activeMonsterIndex;\n\t}\n\n\tstruct MonsterCard {\n\t\tuint256 cardId;\n\t\tuint8 mainType;\n\t\tuint8 secondaryType;\n\t\tStats baseStats;\n\t\tStats stats;\n\t\taddress[4] moves;\n\t\taddress statusCondition;\n\t\tuint8 stausConditionCounter;\n\t\taddress specialStatusCondition;\n\t\tuint8 specialStatusConditionCounter;\n\t\tuint8 activeMoveIndex;\n\t\tuint8 activeMoveCounter;\n\t}\n\n\tstruct Stats {\n\t\tuint8 hp;\n\t\tuint8 attack;\n\t\tuint8 defense;\n\t\tuint8 spAttack;\n\t\tuint8 spDefense;\n\t\tuint8 speed;\n\t\tuint8[4] pp;\n\t}\n\n\tstruct ItemCard {\n\t\tuint256 cardId;\n\t\taddress definition;\n\t\tbool used;\n\t}\n}\n"
    },
    "contracts/Toshimon/interfaces/IMove.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport { ToshimonState as TM } from '../ToshimonState.sol';\n\ninterface IMove {\n\tfunction applyMove(TM.GameState memory state, uint8 mover, bytes32 randomSeed) external pure returns (TM.GameState memory);\n}\n"
    },
    "contracts/Toshimon/interfaces/IItem.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport { ToshimonState as TM } from '../ToshimonState.sol';\n\ninterface IItem {\n\tfunction applyItem(TM.GameState memory state, uint8 mover, uint8 monster, bytes32 randomSeed) external pure returns (TM.GameState memory);\n}\n"
    },
    "contracts/Toshimon/items/Potion.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\n import \"@openzeppelin/contracts/math/Math.sol\";\n\nimport { ToshimonState as TM } from '../ToshimonState.sol';\nimport { IItem } from '../interfaces/IItem.sol';\n\ncontract Potion is IItem {\n\tfunction applyItem(TM.GameState memory state, uint8 mover, uint8 monster, bytes32 randomSeed) external override pure returns (TM.GameState memory) {\n\t\t// add 30 HP to the receiver up to their max HP\n\t\tuint8 currentHp = state.players[mover].monsters[monster].stats.hp;\n\t\tuint8 maxHp = state.players[mover].monsters[monster].baseStats.hp;\n\t\tstate.players[mover].monsters[monster].stats.hp = uint8(Math.min(uint256(currentHp + 30), uint256(maxHp)));\n\t\treturn state;\n\t}\n}\n"
    },
    "@openzeppelin/contracts/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "contracts/Toshimon/moves/Tackle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport { ToshimonState as TM } from '../ToshimonState.sol';\nimport { IMove } from '../interfaces/IMove.sol';\n\ncontract Tackle is IMove {\n\tfunction applyMove(TM.GameState memory state, uint8 mover, bytes32 randomSeed) override external pure returns (TM.GameState memory) {\n\t\treturn state;\n\t}\n}\n"
    },
    "contracts/Toshimon/interfaces/IStatusCondition.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport { ToshimonState as TM } from '../ToshimonState.sol';\n\ninterface IStatusCondition {\n\tfunction onStart(TM.GameState memory state, uint8 mover, uint8 monster, bytes32 randomSeed) external pure returns (TM.GameState memory);\n\n\tfunction onBeforeMove(TM.GameState memory state, uint8 mover, uint8 monster, bytes32 randomSeed) external pure returns (TM.GameState memory, bool);\n\n\tfunction onAfterTurn(TM.GameState memory state, uint8 mover, uint8 monster, bytes32 randomSeed) external pure returns (TM.GameState memory);\n}\n"
    },
    "contracts/StateChannel/MultiAssetHolder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\nimport {ExitFormat as Outcome} from '@statechannels/exit-format/contracts/ExitFormat.sol';\nimport './ForceMove.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport './interfaces/IMultiAssetHolder.sol';\n\n/**\n@dev An implementation of the IMultiAssetHolder interface. The AssetHolder contract escrows ETH or tokens against state channels. It allows assets to be internally accounted for, and ultimately prepared for transfer from one channel to other channels and/or external destinations, as well as for guarantees to be claimed.\n */\ncontract MultiAssetHolder is IMultiAssetHolder, StatusManager {\n    using SafeMath for uint256;\n\n    // *******\n    // Storage\n    // *******\n\n    /**\n     * holdings[asset][channelId] is the amount of asset held against channel channelId. 0 address implies ETH\n     */\n    mapping(address => mapping(bytes32 => uint256)) public holdings;\n\n    // **************\n    // External methods\n    // **************\n\n    /**\n     * @notice Deposit ETH or erc20 tokens against a given channelId.\n     * @dev Deposit ETH or erc20 tokens against a given channelId.\n     * @param asset erc20 token address, or zero address to indicate ETH\n     * @param channelId ChannelId to be credited.\n     * @param expectedHeld The number of wei/tokens the depositor believes are _already_ escrowed against the channelId.\n     * @param amount The intended number of wei/tokens to be deposited.\n     */\n    function deposit(\n        address asset,\n        bytes32 channelId,\n        uint256 expectedHeld,\n        uint256 amount\n    ) external payable override {\n        require(!_isExternalDestination(channelId), 'Deposit to external destination');\n        uint256 amountDeposited;\n        // this allows participants to reduce the wait between deposits, while protecting them from losing funds by depositing too early. Specifically it protects against the scenario:\n        // 1. Participant A deposits\n        // 2. Participant B sees A's deposit, which means it is now safe for them to deposit\n        // 3. Participant B submits their deposit\n        // 4. The chain re-orgs, leaving B's deposit in the chain but not A's\n        uint256 held = holdings[asset][channelId];\n        require(held >= expectedHeld, 'holdings < expectedHeld');\n        require(held < expectedHeld.add(amount), 'holdings already sufficient');\n\n        // The depositor wishes to increase the holdings against channelId to amount + expectedHeld\n        // The depositor need only deposit (at most) amount + (expectedHeld - holdings) (the term in parentheses is non-positive)\n\n        amountDeposited = expectedHeld.add(amount).sub(held); // strictly positive\n        // require successful deposit before updating holdings (protect against reentrancy)\n        if (asset == address(0)) {\n            require(msg.value == amount, 'Incorrect msg.value for deposit');\n        } else {\n            // require successful deposit before updating holdings (protect against reentrancy)\n            require(\n                IERC20(asset).transferFrom(msg.sender, address(this), amountDeposited),\n                'Could not deposit ERC20s'\n            );\n        }\n\n        uint256 nowHeld = held.add(amountDeposited);\n        holdings[asset][channelId] = nowHeld;\n        emit Deposited(channelId, asset, amountDeposited, nowHeld);\n\n        if (asset == address(0)) {\n            // refund whatever wasn't deposited.\n            uint256 refund = amount.sub(amountDeposited);\n            (bool success, ) = msg.sender.call{value: refund}(''); //solhint-disable-line avoid-low-level-calls\n            require(success, 'Could not refund excess funds');\n        }\n    }\n\n    /**\n     * @notice Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries.\n     * @dev Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries.\n     * @param assetIndex Will be used to slice the outcome into a single asset outcome.\n     * @param fromChannelId Unique identifier for state channel to transfer funds *from*.\n     * @param outcomeBytes The encoded Outcome of this state channel\n     * @param stateHash The hash of the state stored when the channel finalized.\n     * @param indices Array with each entry denoting the index of a destination to transfer funds to. An empty array indicates \"all\".\n     */\n    function transfer(\n        uint256 assetIndex, // TODO consider a uint48?\n        bytes32 fromChannelId,\n        bytes memory outcomeBytes,\n        bytes32 stateHash,\n        uint256[] memory indices\n    ) external override {\n        (\n            Outcome.SingleAssetExit[] memory outcome,\n            address asset,\n            uint256 initialAssetHoldings\n        ) = _apply_transfer_checks(assetIndex, indices, fromChannelId, stateHash, outcomeBytes); // view\n\n        (\n            Outcome.Allocation[] memory newAllocations,\n            ,\n            Outcome.Allocation[] memory exitAllocations,\n            uint256 totalPayouts\n        ) = compute_transfer_effects_and_interactions(\n                initialAssetHoldings,\n                outcome[assetIndex].allocations,\n                indices\n            ); // pure, also performs checks\n\n        _apply_transfer_effects(\n            assetIndex,\n            asset,\n            fromChannelId,\n            stateHash,\n            outcome,\n            newAllocations,\n            initialAssetHoldings,\n            totalPayouts\n        );\n        _apply_transfer_interactions(outcome[assetIndex], exitAllocations);\n    }\n\n    function _apply_transfer_checks(\n        uint256 assetIndex,\n        uint256[] memory indices,\n        bytes32 channelId,\n        bytes32 stateHash,\n        bytes memory outcomeBytes\n    )\n        internal\n        view\n        returns (\n            Outcome.SingleAssetExit[] memory outcome,\n            address asset,\n            uint256 initialAssetHoldings\n        )\n    {\n        _requireIncreasingIndices(indices); // This assumption is relied on by compute_transfer_effects_and_interactions\n        _requireChannelFinalized(channelId);\n        _requireMatchingFingerprint(stateHash, keccak256(outcomeBytes), channelId);\n\n        outcome = Outcome.decodeExit(outcomeBytes);\n        asset = outcome[assetIndex].asset;\n        initialAssetHoldings = holdings[asset][channelId];\n    }\n\n    function compute_transfer_effects_and_interactions(\n        uint256 initialHoldings,\n        Outcome.Allocation[] memory allocations,\n        uint256[] memory indices\n    )\n        public\n        pure\n        returns (\n            Outcome.Allocation[] memory newAllocations,\n            bool allocatesOnlyZeros,\n            Outcome.Allocation[] memory exitAllocations,\n            uint256 totalPayouts\n        )\n    {\n        // `indices == []` means \"pay out to all\"\n        // Note: by initializing exitAllocations to be an array of fixed length, its entries are initialized to be `0`\n        exitAllocations = new Outcome.Allocation[](\n            indices.length > 0 ? indices.length : allocations.length\n        );\n        totalPayouts = 0;\n        newAllocations = new Outcome.Allocation[](allocations.length);\n        allocatesOnlyZeros = true; // switched to false if there is an item remaining with amount > 0\n        uint256 surplus = initialHoldings; // tracks funds available during calculation\n        uint256 k = 0; // indexes the `indices` array\n\n        // loop over allocations and decrease surplus\n        for (uint256 i = 0; i < allocations.length; i++) {\n            // copy destination, allocationType and metadata parts\n            newAllocations[i].destination = allocations[i].destination;\n            newAllocations[i].allocationType = allocations[i].allocationType;\n            newAllocations[i].metadata = allocations[i].metadata;\n            // compute new amount part\n            uint256 affordsForDestination = min(allocations[i].amount, surplus);\n            if ((indices.length == 0) || ((k < indices.length) && (indices[k] == i))) {\n                if (allocations[k].allocationType == uint8(Outcome.AllocationType.guarantee))\n                    revert('cannot transfer a guarantee');\n                // found a match\n                // reduce the current allocationItem.amount\n                newAllocations[i].amount = allocations[i].amount - affordsForDestination;\n                // increase the relevant exit allocation\n                exitAllocations[k] = Outcome.Allocation(\n                    allocations[i].destination,\n                    affordsForDestination,\n                    allocations[i].allocationType,\n                    allocations[i].metadata\n                );\n                totalPayouts += affordsForDestination;\n                // move on to the next supplied index\n                ++k;\n            } else {\n                newAllocations[i].amount = allocations[i].amount;\n            }\n            if (newAllocations[i].amount != 0) allocatesOnlyZeros = false;\n            // decrease surplus by the current amount if possible, else surplus goes to zero\n            surplus -= affordsForDestination;\n        }\n    }\n\n    function _apply_transfer_effects(\n        uint256 assetIndex,\n        address asset,\n        bytes32 channelId,\n        bytes32 stateHash,\n        Outcome.SingleAssetExit[] memory outcome,\n        Outcome.Allocation[] memory newAllocations,\n        uint256 initialHoldings,\n        uint256 totalPayouts\n    ) internal {\n        // update holdings\n        holdings[asset][channelId] -= totalPayouts;\n\n        // store fingerprint of modified outcome\n        outcome[assetIndex].allocations = newAllocations;\n        _updateFingerprint(channelId, stateHash, keccak256(abi.encode(outcome)));\n\n        // emit the information needed to compute the new outcome stored in the fingerprint\n        emit AllocationUpdated(channelId, assetIndex, initialHoldings);\n    }\n\n    function _apply_transfer_interactions(\n        Outcome.SingleAssetExit memory singleAssetExit,\n        Outcome.Allocation[] memory exitAllocations\n    ) internal {\n        // create a new tuple to avoid mutating singleAssetExit\n        _executeSingleAssetExit(\n            Outcome.SingleAssetExit(\n                singleAssetExit.asset,\n                singleAssetExit.metadata,\n                exitAllocations\n            )\n        );\n    }\n\n    /**\n     * @notice Executes a single asset exit by paying out the asset and calling external contracts, as well as updating the holdings stored in this contract.\n     * @dev Executes a single asset exit by paying out the asset and calling external contracts, as well as updating the holdings stored in this contract.\n     * @param singleAssetExit The single asset exit to be paid out.\n     */\n    function _executeSingleAssetExit(Outcome.SingleAssetExit memory singleAssetExit) internal {\n        address asset = singleAssetExit.asset;\n        for (uint256 j = 0; j < singleAssetExit.allocations.length; j++) {\n            bytes32 destination = singleAssetExit.allocations[j].destination;\n            uint256 amount = singleAssetExit.allocations[j].amount;\n            if (_isExternalDestination(destination)) {\n                _transferAsset(asset, _bytes32ToAddress(destination), amount);\n            } else {\n                holdings[asset][destination] += amount;\n            }\n        }\n    }\n\n    /**\n     * @notice Transfers the given amount of this AssetHolders's asset type to a supplied ethereum address.\n     * @dev Transfers the given amount of this AssetHolders's asset type to a supplied ethereum address.\n     * @param destination ethereum address to be credited.\n     * @param amount Quantity of assets to be transferred.\n     */\n    function _transferAsset(\n        address asset,\n        address destination,\n        uint256 amount\n    ) internal {\n        if (asset == address(0)) {\n            (bool success, ) = destination.call{value: amount}(''); //solhint-disable-line avoid-low-level-calls\n            require(success, 'Could not transfer ETH');\n        } else {\n            IERC20(asset).transfer(destination, amount);\n        }\n    }\n\n    /**\n     * @notice Checks if a given destination is external (and can therefore have assets transferred to it) or not.\n     * @dev Checks if a given destination is external (and can therefore have assets transferred to it) or not.\n     * @param destination Destination to be checked.\n     * @return True if the destination is external, false otherwise.\n     */\n    function _isExternalDestination(bytes32 destination) internal pure returns (bool) {\n        return uint96(bytes12(destination)) == 0;\n    }\n\n    /**\n     * @notice Converts an ethereum address to a nitro external destination.\n     * @dev Converts an ethereum address to a nitro external destination.\n     * @param participant The address to be converted.\n     * @return The input address left-padded with zeros.\n     */\n    function _addressToBytes32(address participant) internal pure returns (bytes32) {\n        return bytes32(uint256(participant));\n    }\n\n    /**\n     * @notice Converts a nitro destination to an ethereum address.\n     * @dev Converts a nitro destination to an ethereum address.\n     * @param destination The destination to be converted.\n     * @return The rightmost 160 bits of the input string.\n     */\n    function _bytes32ToAddress(bytes32 destination) internal pure returns (address payable) {\n        return address(uint160(uint256(destination)));\n    }\n\n    // **************\n    // Requirers\n    // **************\n\n    /**\n     * @notice Checks that a given variables hash to the data stored on chain.\n     * @dev Checks that a given variables hash to the data stored on chain.\n     */\n    function _requireMatchingFingerprint(\n        bytes32 stateHash,\n        bytes32 outcomeHash,\n        bytes32 channelId\n    ) internal view {\n        (, , uint160 fingerprint) = _unpackStatus(channelId);\n        require(\n            fingerprint == _generateFingerprint(stateHash, outcomeHash),\n            'incorrect fingerprint'\n        );\n    }\n\n    /**\n     * @notice Checks that a given channel is in the Finalized mode.\n     * @dev Checks that a given channel is in the Finalized mode.\n     * @param channelId Unique identifier for a channel.\n     */\n    function _requireChannelFinalized(bytes32 channelId) internal view {\n        require(_mode(channelId) == ChannelMode.Finalized, 'Channel not finalized.');\n    }\n\n    function _updateFingerprint(\n        bytes32 channelId,\n        bytes32 stateHash,\n        bytes32 outcomeHash\n    ) internal {\n        (uint48 turnNumRecord, uint48 finalizesAt, ) = _unpackStatus(channelId);\n\n        bytes32 newStatus = _generateStatus(\n            ChannelData(turnNumRecord, finalizesAt, stateHash, outcomeHash)\n        );\n        statusOf[channelId] = newStatus;\n    }\n\n    /**\n     * @notice Checks that the supplied indices are strictly increasing.\n     * @dev Checks that the supplied indices are strictly increasing. This allows us allows us to write a more efficient claim function.\n     */\n    function _requireIncreasingIndices(uint256[] memory indices) internal pure {\n        for (uint256 i = 0; i + 1 < indices.length; i++) {\n            require(indices[i] < indices[i + 1], 'Indices must be sorted');\n        }\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? b : a;\n    }\n\n    function decodeGuaranteeData(bytes memory data) internal pure returns (bytes32[] memory) {\n        return abi.decode(data, (bytes32[]));\n    }\n}\n"
    },
    "contracts/StateChannel/ForceMove.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {ExitFormat as Outcome} from '@statechannels/exit-format/contracts/ExitFormat.sol';\nimport './interfaces/IForceMove.sol';\nimport './interfaces/IForceMoveApp.sol';\nimport './StatusManager.sol';\n\n/**\n * @dev An implementation of ForceMove protocol, which allows state channels to be adjudicated and finalized.\n */\ncontract ForceMove is IForceMove, StatusManager {\n    // *****************\n    // External methods:\n    // *****************\n\n    /**\n     * @notice Unpacks turnNumRecord, finalizesAt and fingerprint from the status of a particular channel.\n     * @dev Unpacks turnNumRecord, finalizesAt and fingerprint from the status of a particular channel.\n     * @param channelId Unique identifier for a state channel.\n     * @return turnNumRecord A turnNum that (the adjudicator knows) is supported by a signature from each participant.\n     * @return finalizesAt The unix timestamp when `channelId` will finalize.\n     * @return fingerprint The last 160 bits of kecca256(stateHash, outcomeHash)\n     */\n    function unpackStatus(bytes32 channelId)\n        external\n        view\n        returns (\n            uint48 turnNumRecord,\n            uint48 finalizesAt,\n            uint160 fingerprint\n        )\n    {\n        (turnNumRecord, finalizesAt, fingerprint) = _unpackStatus(channelId);\n    }\n\n    /**\n     * @notice Registers a challenge against a state channel. A challenge will either prompt another participant into clearing the challenge (via one of the other methods), or cause the channel to finalize at a specific time.\n     * @dev Registers a challenge against a state channel. A challenge will either prompt another participant into clearing the challenge (via one of the other methods), or cause the channel to finalize at a specific time.\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\n     * @param variableParts An ordered array of structs, each decribing the properties of the state channel that may change with each state update. Length is from 1 to the number of participants (inclusive).\n     * @param sigs An array of signatures that support the state with the `largestTurnNum`. There must be one for each participant, e.g.: [sig-from-p0, sig-from-p1, ...]\n     * @param whoSignedWhat An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\n     * @param challengerSig The signature of a participant on the keccak256 of the abi.encode of (supportedStateHash, 'forceMove').\n     */\n    function challenge(\n        FixedPart memory fixedPart,\n        IForceMoveApp.VariablePart[] memory variableParts,\n        Signature[] memory sigs,\n        uint8[] memory whoSignedWhat,\n        Signature memory challengerSig\n    ) external override {\n        // input type validation\n        requireValidInput(\n            fixedPart.participants.length,\n            variableParts.length,\n            sigs.length,\n            whoSignedWhat.length\n        );\n\n        bytes32 channelId = _getChannelId(fixedPart);\n        uint48 largestTurnNum = _lastVariablePart(variableParts).turnNum;\n\n        if (_mode(channelId) == ChannelMode.Open) {\n            _requireNonDecreasedTurnNumber(channelId, largestTurnNum);\n        } else if (_mode(channelId) == ChannelMode.Challenge) {\n            _requireIncreasedTurnNumber(channelId, largestTurnNum);\n        } else {\n            // This should revert.\n            _requireChannelNotFinalized(channelId);\n        }\n        bytes32 supportedStateHash = _requireStateSupportedBy(\n            variableParts,\n            channelId,\n            fixedPart,\n            sigs,\n            whoSignedWhat\n        );\n\n        _requireChallengerIsParticipant(supportedStateHash, fixedPart.participants, challengerSig);\n\n        // effects\n\n        emit ChallengeRegistered(\n            channelId,\n            largestTurnNum,\n            uint48(block.timestamp) + fixedPart.challengeDuration, //solhint-disable-line not-rely-on-time\n            // This could overflow, so don't join a channel with a huge challengeDuration\n            _lastVariablePart(variableParts).isFinal,\n            fixedPart,\n            variableParts,\n            sigs,\n            whoSignedWhat\n        );\n\n        statusOf[channelId] = _generateStatus(\n            ChannelData(\n                largestTurnNum,\n                uint48(block.timestamp) + fixedPart.challengeDuration, //solhint-disable-line not-rely-on-time\n                supportedStateHash,\n                _hashOutcome(_lastVariablePart(variableParts).outcome)\n            )\n        );\n    }\n\n    /**\n     * @notice Repsonds to an ongoing challenge registered against a state channel.\n     * @dev Repsonds to an ongoing challenge registered against a state channel.\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\n     * @param variablePartAB An pair of structs, each decribing the properties of the state channel that may change with each state update (for the challenge state and for the response state).\n     * @param sig The responder's signature on the `responseStateHash`.\n     */\n    function respond(\n        FixedPart memory fixedPart,\n        IForceMoveApp.VariablePart[2] memory variablePartAB,\n        // variablePartAB[0] = challengeVariablePart\n        // variablePartAB[1] = responseVariablePart\n        Signature memory sig\n    ) external override {\n        // No need to validate fixedPart.participants.length here, as that validation would have happened during challenge\n\n        bytes32 channelId = _getChannelId(fixedPart);\n        (uint48 turnNumRecord, uint48 finalizesAt, ) = _unpackStatus(channelId);\n\n        bytes32 challengeStateHash = _hashState(\n            channelId,\n            variablePartAB[0].appData,\n            variablePartAB[0].outcome,\n            turnNumRecord,\n            variablePartAB[0].isFinal\n        );\n\n        bytes32 responseStateHash = _hashState(\n            channelId,\n            variablePartAB[1].appData,\n            variablePartAB[1].outcome,\n            turnNumRecord + 1,\n            variablePartAB[1].isFinal\n        );\n\n        // checks\n\n        _requireSpecificChallenge(\n            ChannelData(\n                turnNumRecord,\n                finalizesAt,\n                challengeStateHash,\n                _hashOutcome(variablePartAB[0].outcome)\n            ),\n            channelId\n        );\n\n        require(\n            _recoverSigner(responseStateHash, sig) ==\n                fixedPart.participants[(turnNumRecord + 1) % fixedPart.participants.length],\n            'Signer not authorized mover'\n        );\n\n        _requireValidTransition(\n            fixedPart.participants.length,\n            variablePartAB,\n            fixedPart.appDefinition\n        );\n\n        // effects\n        _clearChallenge(channelId, turnNumRecord + 1);\n    }\n\n    /**\n     * @notice Overwrites the `turnNumRecord` stored against a channel by providing a state with higher turn number, supported by a signature from each participant.\n     * @dev Overwrites the `turnNumRecord` stored against a channel by providing a state with higher turn number, supported by a signature from each participant.\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\n     * @param variableParts An ordered array of structs, each decribing the properties of the state channel that may change with each state update.\n     * @param sigs An array of signatures that support the state with the `largestTurnNum`: one for each participant, in participant order (e.g. [sig of participant[0], sig of participant[1], ...]).\n     * @param whoSignedWhat An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\n     */\n    function checkpoint(\n        FixedPart memory fixedPart,\n        IForceMoveApp.VariablePart[] memory variableParts,\n        Signature[] memory sigs,\n        uint8[] memory whoSignedWhat\n    ) external override {\n        // input type validation\n        requireValidInput(\n            fixedPart.participants.length,\n            variableParts.length,\n            sigs.length,\n            whoSignedWhat.length\n        );\n\n        bytes32 channelId = _getChannelId(fixedPart);\n        uint48 largestTurnNum = _lastVariablePart(variableParts).turnNum;\n\n        // checks\n        _requireChannelNotFinalized(channelId);\n        _requireIncreasedTurnNumber(channelId, largestTurnNum);\n        _requireStateSupportedBy(variableParts, channelId, fixedPart, sigs, whoSignedWhat);\n\n        // effects\n        _clearChallenge(channelId, largestTurnNum);\n    }\n\n    /**\n     * @notice Finalizes a channel by providing a finalization proof. External wrapper for _conclude.\n     * @dev Finalizes a channel by providing a finalization proof. External wrapper for _conclude.\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\n     * @param latestVariablePart Latest variable part in finalization proof. Must have the largest turnNum and the same appData and outcome as all other variable parts in finalization proof.\n     * @param numStates The number of states in the finalization proof.\n     * @param whoSignedWhat An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\n     * @param sigs An array of signatures that support the state with the `largestTurnNum`: one for each participant, in participant order (e.g. [sig of participant[0], sig of participant[1], ...]).\n     */\n    function conclude(\n        FixedPart memory fixedPart,\n        IForceMoveApp.VariablePart memory latestVariablePart,\n        uint8 numStates,\n        uint8[] memory whoSignedWhat,\n        Signature[] memory sigs\n    ) external override {\n        _conclude(fixedPart, latestVariablePart, numStates, whoSignedWhat, sigs);\n    }\n\n    /**\n     * @notice Finalizes a channel by providing a finalization proof. Internal method.\n     * @dev Finalizes a channel by providing a finalization proof. Internal method.\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\n     * @param latestVariablePart Latest variable part in finalization proof. Must have the largest turnNum and the same appData and outcome as all other variable parts in finalization proof.\n     * @param numStates The number of states in the finalization proof.\n     * @param whoSignedWhat An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\n     * @param sigs An array of signatures that support the state with the `largestTurnNum`:: one for each participant, in participant order (e.g. [sig of participant[0], sig of participant[1], ...]).\n     */\n    function _conclude(\n        FixedPart memory fixedPart,\n        IForceMoveApp.VariablePart memory latestVariablePart,\n        uint8 numStates,\n        uint8[] memory whoSignedWhat,\n        Signature[] memory sigs\n    ) internal returns (bytes32 channelId) {\n        channelId = _getChannelId(fixedPart);\n        _requireChannelNotFinalized(channelId);\n\n        // input type validation\n        requireValidInput(\n            fixedPart.participants.length,\n            numStates,\n            sigs.length,\n            whoSignedWhat.length\n        );\n\n        require(latestVariablePart.turnNum + 1 >= numStates, 'largestTurnNum too low');\n        // ^^ SW-C101: prevent underflow\n\n        // By construction, the following states form a valid transition\n        bytes32[] memory stateHashes = new bytes32[](numStates);\n        for (uint48 i = 0; i < numStates; i++) {\n            stateHashes[i] = _hashState(\n                channelId,\n                latestVariablePart.appData,\n                latestVariablePart.outcome,\n                latestVariablePart.turnNum + (i + 1) - numStates, // turnNum\n                // ^^ SW-C101: It is not easy to use SafeMath here, since we are not using uint256s\n                // Instead, we are protected by the require statement above\n                true // isFinal\n            );\n        }\n\n        // checks\n        require(\n            _validSignatures(\n                latestVariablePart.turnNum,\n                fixedPart.participants,\n                stateHashes,\n                sigs,\n                whoSignedWhat\n            ),\n            'Invalid signatures / !isFinal'\n        );\n\n        // effects\n        statusOf[channelId] = _generateStatus(\n            ChannelData(\n                0,\n                uint48(block.timestamp), //solhint-disable-line not-rely-on-time\n                bytes32(0),\n                _hashOutcome(latestVariablePart.outcome)\n            )\n        );\n        emit Concluded(channelId, uint48(block.timestamp)); //solhint-disable-line not-rely-on-time\n    }\n\n    function getChainID() public pure returns (uint256) {\n        uint256 id;\n        /* solhint-disable no-inline-assembly */\n        assembly {\n            id := chainid()\n        }\n        /* solhint-disable no-inline-assembly */\n        return id;\n    }\n\n    /**\n     * @notice Validates input for several external methods.\n     * @dev Validates input for several external methods.\n     * @param numParticipants Length of the participants array\n     * @param numStates Number of states submitted\n     * @param numSigs Number of signatures submitted\n     * @param numWhoSignedWhats whoSignedWhat.length\n     */\n    function requireValidInput(\n        uint256 numParticipants,\n        uint256 numStates,\n        uint256 numSigs,\n        uint256 numWhoSignedWhats\n    ) public pure returns (bool) {\n        require((numParticipants >= numStates) && (numStates > 0), 'Insufficient or excess states');\n        require(\n            (numSigs == numParticipants) && (numWhoSignedWhats == numParticipants),\n            'Bad |signatures|v|whoSignedWhat|'\n        );\n        require(numParticipants <= type(uint8).max, 'Too many participants!'); // type(uint8).max = 2**8 - 1 = 255\n        // no more than 255 participants\n        // max index for participants is 254\n        return true;\n    }\n\n    // *****************\n    // Internal methods:\n    // *****************\n\n    /**\n     * @notice Checks that the challengerSignature was created by one of the supplied participants.\n     * @dev Checks that the challengerSignature was created by one of the supplied participants.\n     * @param supportedStateHash Forms part of the digest to be signed, along with the string 'forceMove'.\n     * @param participants A list of addresses representing the participants of a channel.\n     * @param challengerSignature The signature of a participant on the keccak256 of the abi.encode of (supportedStateHash, 'forceMove').\n     */\n    function _requireChallengerIsParticipant(\n        bytes32 supportedStateHash,\n        address[] memory participants,\n        Signature memory challengerSignature\n    ) internal pure {\n        address challenger = _recoverSigner(\n            keccak256(abi.encode(supportedStateHash, 'forceMove')),\n            challengerSignature\n        );\n        require(_isAddressInArray(challenger, participants), 'Challenger is not a participant');\n    }\n\n    /**\n     * @notice Tests whether a given address is in a given array of addresses.\n     * @dev Tests whether a given address is in a given array of addresses.\n     * @param suspect A single address of interest.\n     * @param addresses A line-up of possible perpetrators.\n     * @return true if the address is in the array, false otherwise\n     */\n    function _isAddressInArray(address suspect, address[] memory addresses)\n        internal\n        pure\n        returns (bool)\n    {\n        for (uint256 i = 0; i < addresses.length; i++) {\n            if (suspect == addresses[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @notice Given an array of state hashes, checks the validity of the supplied signatures. Valid means there is a signature for each participant, either on the hash of the state for which they are a mover, or on the hash of a state that appears after that state in the array.\n     * @dev Given an array of state hashes, checks the validity of the supplied signatures. Valid means there is a signature for each participant, either on the hash of the state for which they are a mover, or on the hash of a state that appears after that state in the array.\n     * @param largestTurnNum The largest turn number of the submitted states; will overwrite the stored value of `turnNumRecord`.\n     * @param participants A list of addresses representing the participants of a channel.\n     * @param stateHashes Array of keccak256(State) submitted in support of a state,\n     * @param sigs Array of Signatures, one for each participant, in participant order (e.g. [sig of participant[0], sig of participant[1], ...]).\n     * @param whoSignedWhat participant[i] signed stateHashes[whoSignedWhat[i]]\n     * @return true if the signatures are valid, false otherwise\n     */\n    function _validSignatures(\n        uint48 largestTurnNum,\n        address[] memory participants,\n        bytes32[] memory stateHashes,\n        Signature[] memory sigs,\n        uint8[] memory whoSignedWhat // whoSignedWhat[i] is the index of the state in stateHashes that was signed by participants[i]\n    ) internal pure returns (bool) {\n        uint256 nParticipants = participants.length;\n        uint256 nStates = stateHashes.length;\n\n        require(\n            _acceptableWhoSignedWhat(whoSignedWhat, largestTurnNum, nParticipants, nStates),\n            'Unacceptable whoSignedWhat array'\n        );\n        for (uint256 i = 0; i < nParticipants; i++) {\n            address signer = _recoverSigner(stateHashes[whoSignedWhat[i]], sigs[i]);\n            if (signer != participants[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Given a declaration of which state in the support proof was signed by which participant, check if this declaration is acceptable. Acceptable means there is a signature for each participant, either on the hash of the state for which they are a mover, or on the hash of a state that appears after that state in the array.\n     * @dev Given a declaration of which state in the support proof was signed by which participant, check if this declaration is acceptable. Acceptable means there is a signature for each participant, either on the hash of the state for which they are a mover, or on the hash of a state that appears after that state in the array.\n     * @param whoSignedWhat participant[i] signed stateHashes[whoSignedWhat[i]]\n     * @param largestTurnNum Largest turnNum of the support proof\n     * @param nParticipants Number of participants in the channel\n     * @param nStates Number of states in the support proof\n     * @return true if whoSignedWhat is acceptable, false otherwise\n     */\n    function _acceptableWhoSignedWhat(\n        uint8[] memory whoSignedWhat,\n        uint48 largestTurnNum,\n        uint256 nParticipants,\n        uint256 nStates\n    ) internal pure returns (bool) {\n        require(whoSignedWhat.length == nParticipants, '|whoSignedWhat|!=nParticipants');\n        for (uint256 i = 0; i < nParticipants; i++) {\n            uint256 offset = (nParticipants + largestTurnNum - i) % nParticipants;\n            // offset is the difference between the index of participant[i] and the index of the participant who owns the largesTurnNum state\n            // the additional nParticipants in the dividend ensures offset always positive\n            if (whoSignedWhat[i] + offset + 1 < nStates) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Given a digest and ethereum digital signature, recover the signer\n     * @dev Given a digest and digital signature, recover the signer\n     * @param _d message digest\n     * @param sig ethereum digital signature\n     * @return signer\n     */\n    function _recoverSigner(bytes32 _d, Signature memory sig) internal pure returns (address) {\n        bytes32 prefixedHash = keccak256(abi.encodePacked('\\x19Ethereum Signed Message:\\n32', _d));\n        address a = ecrecover(prefixedHash, sig.v, sig.r, sig.s);\n        require(a != address(0), 'Invalid signature');\n        return (a);\n    }\n\n    /**\n     * @notice Check that the submitted data constitute a support proof.\n     * @dev Check that the submitted data constitute a support proof.\n     * @param variableParts Variable parts of the states in the support proof\n     * @param channelId Unique identifier for a channel.\n     * @param fixedPart Fixed Part of the states in the support proof\n     * @param sigs A signature from each participant, in participant order (e.g. [sig of participant[0], sig of participant[1], ...]).\n     * @param whoSignedWhat participant[i] signed stateHashes[whoSignedWhat[i]]\n     * @return The hash of the latest state in the proof, if supported, else reverts.\n     */\n    function _requireStateSupportedBy(\n        IForceMoveApp.VariablePart[] memory variableParts,\n        bytes32 channelId,\n        FixedPart memory fixedPart,\n        Signature[] memory sigs,\n        uint8[] memory whoSignedWhat\n    ) internal pure returns (bytes32) {\n        bytes32[] memory stateHashes = _requireValidTransitionChain(\n            variableParts,\n            channelId,\n            fixedPart\n        );\n\n        require(\n            _validSignatures(\n                _lastVariablePart(variableParts).turnNum,\n                fixedPart.participants,\n                stateHashes,\n                sigs,\n                whoSignedWhat\n            ),\n            'Invalid signatures'\n        );\n\n        return stateHashes[stateHashes.length - 1];\n    }\n\n    /**\n     * @notice Check that the submitted states form a chain of valid transitions\n     * @dev Check that the submitted states form a chain of valid transitions\n     * @param variableParts Variable parts of the states in the support proof\n     * @param channelId Unique identifier for a channel.\n     * @param fixedPart Fixed Part of the states in the support proof\n     * @return true if every state is a validTransition from its predecessor, false otherwise.\n     */\n    function _requireValidTransitionChain(\n        // returns stateHashes array if valid\n        // else, reverts\n        IForceMoveApp.VariablePart[] memory variableParts,\n        bytes32 channelId,\n        FixedPart memory fixedPart\n    ) internal pure returns (bytes32[] memory) {\n        bytes32[] memory stateHashes = new bytes32[](variableParts.length);\n\n        for (uint48 i = 0; i < variableParts.length; i++) {\n            stateHashes[i] = _hashState(\n                channelId,\n                variableParts[i].appData,\n                variableParts[i].outcome,\n                variableParts[i].turnNum,\n                variableParts[i].isFinal\n            );\n            if (i < variableParts.length - 1) {\n                _requireValidTransition(\n                    fixedPart.participants.length,\n                    [variableParts[i], variableParts[i + 1]],\n                    fixedPart.appDefinition\n                );\n            }\n        }\n        return stateHashes;\n    }\n\n    enum IsValidTransition {\n        True,\n        NeedToCheckApp\n    }\n\n    /**\n    * @notice Check that the submitted pair of states form a valid transition\n    * @dev Check that the submitted pair of states form a valid transition\n    * @param nParticipants Number of participants in the channel.\n    transition\n    * @param ab Variable parts of each of the pair of states\n    * @return true if the later state is a validTransition from its predecessor, false otherwise.\n    */\n    function _requireValidProtocolTransition(\n        uint256 nParticipants,\n        IForceMoveApp.VariablePart[2] memory ab // [a,b]\n    ) internal pure returns (IsValidTransition) {\n        // a separate check on the signatures for the submitted states implies that the following fields are equal for a and b:\n        // chainId, participants, channelNonce, appDefinition, challengeDuration\n        // and that the b.turnNum = a.turnNum + 1\n        if (ab[1].isFinal) {\n            require(Outcome.exitsEqual(ab[1].outcome, ab[0].outcome), 'Outcome change verboten');\n        } else {\n            require(!ab[0].isFinal, 'isFinal retrograde');\n            if (ab[1].turnNum < 2 * nParticipants) {\n                require(\n                    Outcome.exitsEqual(ab[1].outcome, ab[0].outcome),\n                    'Outcome change forbidden'\n                );\n                require(_bytesEqual(ab[1].appData, ab[0].appData), 'appData change forbidden');\n            } else {\n                return IsValidTransition.NeedToCheckApp;\n            }\n        }\n        return IsValidTransition.True;\n    }\n\n    /**\n    * @notice Check that the submitted pair of states form a valid transition\n    * @dev Check that the submitted pair of states form a valid transition\n    * @param nParticipants Number of participants in the channel.\n    transition\n    * @param ab Variable parts of each of the pair of states\n    * @param appDefinition Address of deployed contract containing application-specific validTransition function.\n    * @return true if the later state is a validTransition from its predecessor, false otherwise.\n    */\n    function _requireValidTransition(\n        uint256 nParticipants,\n        IForceMoveApp.VariablePart[2] memory ab, // [a,b]\n        address appDefinition\n    ) internal pure returns (bool) {\n        IsValidTransition isValidProtocolTransition = _requireValidProtocolTransition(\n            nParticipants,\n            ab // [a,b]\n        );\n\n        if (isValidProtocolTransition == IsValidTransition.NeedToCheckApp) {\n            require(\n                IForceMoveApp(appDefinition).validTransition(ab[0], ab[1], nParticipants),\n                'Invalid ForceMoveApp Transition'\n            );\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Check for equality of two byte strings\n     * @dev Check for equality of two byte strings\n     * @param _preBytes One bytes string\n     * @param _postBytes The other bytes string\n     * @return true if the bytes are identical, false otherwise.\n     */\n    function _bytesEqual(bytes memory _preBytes, bytes memory _postBytes)\n        internal\n        pure\n        returns (bool)\n    {\n        // copied from https://www.npmjs.com/package/solidity-bytes-utils/v/0.1.1\n        bool success = true;\n\n        /* solhint-disable no-inline-assembly */\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                    // the next line is the loop condition:\n                    // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n        /* solhint-disable no-inline-assembly */\n\n        return success;\n    }\n\n    /**\n     * @notice Clears a challenge by updating the turnNumRecord and resetting the remaining channel storage fields, and emits a ChallengeCleared event.\n     * @dev Clears a challenge by updating the turnNumRecord and resetting the remaining channel storage fields, and emits a ChallengeCleared event.\n     * @param channelId Unique identifier for a channel.\n     * @param newTurnNumRecord New turnNumRecord to overwrite existing value\n     */\n    function _clearChallenge(bytes32 channelId, uint48 newTurnNumRecord) internal {\n        statusOf[channelId] = _generateStatus(\n            ChannelData(newTurnNumRecord, 0, bytes32(0), bytes32(0))\n        );\n        emit ChallengeCleared(channelId, newTurnNumRecord);\n    }\n\n    /**\n     * @notice Checks that the submitted turnNumRecord is strictly greater than the turnNumRecord stored on chain.\n     * @dev Checks that the submitted turnNumRecord is strictly greater than the turnNumRecord stored on chain.\n     * @param channelId Unique identifier for a channel.\n     * @param newTurnNumRecord New turnNumRecord intended to overwrite existing value\n     */\n    function _requireIncreasedTurnNumber(bytes32 channelId, uint48 newTurnNumRecord) internal view {\n        (uint48 turnNumRecord, , ) = _unpackStatus(channelId);\n        require(newTurnNumRecord > turnNumRecord, 'turnNumRecord not increased.');\n    }\n\n    /**\n     * @notice Checks that the submitted turnNumRecord is greater than or equal to the turnNumRecord stored on chain.\n     * @dev Checks that the submitted turnNumRecord is greater than or equal to the turnNumRecord stored on chain.\n     * @param channelId Unique identifier for a channel.\n     * @param newTurnNumRecord New turnNumRecord intended to overwrite existing value\n     */\n    function _requireNonDecreasedTurnNumber(bytes32 channelId, uint48 newTurnNumRecord)\n        internal\n        view\n    {\n        (uint48 turnNumRecord, , ) = _unpackStatus(channelId);\n        require(newTurnNumRecord >= turnNumRecord, 'turnNumRecord decreased.');\n    }\n\n    /**\n     * @notice Checks that a given ChannelData struct matches the challenge stored on chain, and that the channel is in Challenge mode.\n     * @dev Checks that a given ChannelData struct matches the challenge stored on chain, and that the channel is in Challenge mode.\n     * @param data A given ChannelData data structure.\n     * @param channelId Unique identifier for a channel.\n     */\n    function _requireSpecificChallenge(ChannelData memory data, bytes32 channelId) internal view {\n        _requireMatchingStorage(data, channelId);\n        _requireOngoingChallenge(channelId);\n    }\n\n    /**\n     * @notice Checks that a given channel is in the Challenge mode.\n     * @dev Checks that a given channel is in the Challenge mode.\n     * @param channelId Unique identifier for a channel.\n     */\n    function _requireOngoingChallenge(bytes32 channelId) internal view {\n        require(_mode(channelId) == ChannelMode.Challenge, 'No ongoing challenge.');\n    }\n\n    /**\n     * @notice Checks that a given channel is NOT in the Finalized mode.\n     * @dev Checks that a given channel is in the Challenge mode.\n     * @param channelId Unique identifier for a channel.\n     */\n    function _requireChannelNotFinalized(bytes32 channelId) internal view {\n        require(_mode(channelId) != ChannelMode.Finalized, 'Channel finalized.');\n    }\n\n    /**\n     * @notice Checks that a given channel is in the Open mode.\n     * @dev Checks that a given channel is in the Challenge mode.\n     * @param channelId Unique identifier for a channel.\n     */\n    function _requireChannelOpen(bytes32 channelId) internal view {\n        require(_mode(channelId) == ChannelMode.Open, 'Channel not open.');\n    }\n\n    /**\n     * @notice Checks that a given ChannelData struct matches the challenge stored on chain.\n     * @dev Checks that a given ChannelData struct matches the challenge stored on chain.\n     * @param data A given ChannelData data structure.\n     * @param channelId Unique identifier for a channel.\n     */\n    function _requireMatchingStorage(ChannelData memory data, bytes32 channelId) internal view {\n        require(_matchesStatus(data, statusOf[channelId]), 'status(ChannelData)!=storage');\n    }\n\n    /**\n     * @notice Checks that a given ChannelData struct matches a supplied bytes32 when formatted for storage.\n     * @dev Checks that a given ChannelData struct matches a supplied bytes32 when formatted for storage.\n     * @param data A given ChannelData data structure.\n     * @param s Some data in on-chain storage format.\n     */\n    function _matchesStatus(ChannelData memory data, bytes32 s) internal pure returns (bool) {\n        return _generateStatus(data) == s;\n    }\n\n    /**\n     * @notice Computes the hash of the state corresponding to the input data.\n     * @dev Computes the hash of the state corresponding to the input data.\n     * @param turnNum Turn number\n     * @param isFinal Is the state final?\n     * @param channelId Unique identifier for the channel\n     * @param appData Application specific data.\n     * @param outcome Outcome structure.\n     * @return The stateHash\n     */\n    function _hashState(\n        bytes32 channelId,\n        bytes memory appData,\n        Outcome.SingleAssetExit[] memory outcome,\n        uint48 turnNum,\n        bool isFinal\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(channelId, appData, outcome, turnNum, isFinal));\n    }\n\n    /**\n     * @notice Hashes the outcome structure. Internal helper.\n     * @dev Hashes the outcome structure. Internal helper.\n     * @param outcome Outcome structure to encode hash.\n     * @return bytes32 Hash of encoded outcome structure.\n     */\n    function _hashOutcome(Outcome.SingleAssetExit[] memory outcome)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(Outcome.encodeExit(outcome));\n    }\n\n    /**\n     * @notice Computes the unique id of a channel.\n     * @dev Computes the unique id of a channel.\n     * @param fixedPart Part of the state that does not change\n     * @return channelId\n     */\n    function _getChannelId(FixedPart memory fixedPart) internal pure returns (bytes32 channelId) {\n        require(fixedPart.chainId == getChainID(), 'Incorrect chainId');\n        channelId = keccak256(\n            abi.encode(\n                getChainID(),\n                fixedPart.participants,\n                fixedPart.channelNonce,\n                fixedPart.appDefinition,\n                fixedPart.challengeDuration\n            )\n        );\n    }\n\n    /**\n     * @notice Returns the last VariablePart from array.\n     * @dev Returns the last VariablePart from array.\n     * @param variableParts Array of VariableParts.\n     * @return VariablePart Last VariablePart from array.\n     */\n    function _lastVariablePart(IForceMoveApp.VariablePart[] memory variableParts)\n        internal\n        pure\n        returns (IForceMoveApp.VariablePart memory)\n    {\n        return variableParts[variableParts.length - 1];\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/StateChannel/interfaces/IMultiAssetHolder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {ExitFormat as Outcome} from '@statechannels/exit-format/contracts/ExitFormat.sol';\n\n/**\n * @dev The IMultiAssetHolder interface calls for functions that allow assets to be transferred from one channel to other channel and/or external destinations, as well as for guarantees to be claimed.\n */\ninterface IMultiAssetHolder {\n    \n    /**\n     * @notice Deposit ETH or erc20 assets against a given destination.\n     * @dev Deposit ETH or erc20 assets against a given destination.\n     * @param asset erc20 token address, or zero address to indicate ETH\n     * @param destination ChannelId to be credited.\n     * @param expectedHeld The number of wei the depositor believes are _already_ escrowed against the channelId.\n     * @param amount The intended number of wei to be deposited.\n     */\n    function deposit(\n        address asset,\n        bytes32 destination,\n        uint256 expectedHeld,\n        uint256 amount\n    ) external payable;\n\n    /**\n     * @notice Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries.\n     * @dev Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries.\n     * @param assetIndex Will be used to slice the outcome into a single asset outcome.\n     * @param fromChannelId Unique identifier for state channel to transfer funds *from*.\n     * @param outcomeBytes The encoded Outcome of this state channel\n     * @param stateHash The hash of the state stored when the channel finalized.\n     * @param indices Array with each entry denoting the index of a destination to transfer funds to. An empty array indicates \"all\".\n     */\n    function transfer(\n        uint256 assetIndex, // TODO consider a uint48?\n        bytes32 fromChannelId,\n        bytes memory outcomeBytes,\n        bytes32 stateHash,\n        uint256[] memory indices\n    ) external;\n\n    /**\n     * @dev Indicates that `amountDeposited` has been deposited into `destination`.\n     * @param destination The channel being deposited into.\n     * @param amountDeposited The amount being deposited.\n     * @param destinationHoldings The new holdings for `destination`.\n     */\n    event Deposited(\n        bytes32 indexed destination,\n        address asset,\n        uint256 amountDeposited,\n        uint256 destinationHoldings\n    );\n\n    /**\n     * @dev Indicates the assetOutcome for this channelId and assetIndex has changed due to a transfer or claim. Includes sufficient data to compute:\n     * - the new assetOutcome\n     * - the new holdings for this channelId and any others that were transferred to\n     * - the payouts to external destinations\n     * @param channelId The channelId of the funds being withdrawn.\n     * @param initialHoldings holdings[asset][channelId] **before** the allocations were updated. The asset in question can be inferred from the calldata of the transaction (it might be \"all assets\")\n     */\n    event AllocationUpdated(bytes32 indexed channelId, uint256 assetIndex, uint256 initialHoldings);\n}\n"
    },
    "contracts/StateChannel/interfaces/IForceMove.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport './IForceMoveApp.sol';\n\n/**\n * @dev The IForceMove interface defines the interface that an implementation of ForceMove should implement. ForceMove protocol allows state channels to be adjudicated and finalized.\n */\ninterface IForceMove {\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct FixedPart {\n        uint256 chainId;\n        address[] participants;\n        uint48 channelNonce;\n        address appDefinition;\n        uint48 challengeDuration;\n    }\n\n    struct State {\n        // participants sign the hash of this\n        bytes32 channelId; // keccack(chainId,participants,channelNonce,appDefinition,challengeDuration)\n        bytes appData;\n        bytes outcome;\n        uint48 turnNum;\n        bool isFinal;\n    }\n\n    /**\n     * @notice Registers a challenge against a state channel. A challenge will either prompt another participant into clearing the challenge (via one of the other methods), or cause the channel to finalize at a specific time.\n     * @dev Registers a challenge against a state channel. A challenge will either prompt another participant into clearing the challenge (via one of the other methods), or cause the channel to finalize at a specific time.\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\n     * @param variableParts An ordered array of structs, each decribing the properties of the state channel that may change with each state update. Length is from 1 to the number of participants (inclusive).\n     * @param sigs An array of signatures that support the state with the `largestTurnNum`. There must be one for each participant, e.g.: [sig-from-p0, sig-from-p1, ...]\n     * @param whoSignedWhat An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\n     * @param challengerSig The signature of a participant on the keccak256 of the abi.encode of (supportedStateHash, 'forceMove').\n     */\n    function challenge(\n        FixedPart memory fixedPart,\n        IForceMoveApp.VariablePart[] memory variableParts,\n        Signature[] memory sigs,\n        uint8[] memory whoSignedWhat,\n        Signature memory challengerSig\n    ) external;\n\n    /**\n     * @notice Repsonds to an ongoing challenge registered against a state channel.\n     * @dev Repsonds to an ongoing challenge registered against a state channel.\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\n     * @param variablePartAB An pair of structs, each decribing the properties of the state channel that may change with each state update (for the challenge state and for the response state).\n     * @param sig The responder's signature on the `responseStateHash`.\n     */\n    function respond(\n        FixedPart memory fixedPart,\n        IForceMoveApp.VariablePart[2] memory variablePartAB,\n        // variablePartAB[0] = challengeVariablePart\n        // variablePartAB[1] = responseVariablePart\n        Signature memory sig\n    ) external;\n\n    /**\n     * @notice Overwrites the `turnNumRecord` stored against a channel by providing a state with higher turn number, supported by a signature from each participant.\n     * @dev Overwrites the `turnNumRecord` stored against a channel by providing a state with higher turn number, supported by a signature from each participant.\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\n     * @param variableParts An ordered array of structs, each decribing the properties of the state channel that may change with each state update.\n     * @param sigs An array of signatures that support the state with the `largestTurnNum`: one for each participant, in participant order (e.g. [sig of participant[0], sig of participant[1], ...]).\n     * @param whoSignedWhat An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\n     */\n    function checkpoint(\n        FixedPart memory fixedPart,\n        IForceMoveApp.VariablePart[] memory variableParts,\n        Signature[] memory sigs,\n        uint8[] memory whoSignedWhat\n    ) external;\n\n    /**\n     * @notice Finalizes a channel by providing a finalization proof. External wrapper for _conclude.\n     * @dev Finalizes a channel by providing a finalization proof. External wrapper for _conclude.\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\n     * @param latestVariablePart Latest variable part in finalization proof. Must have the largest turnNum and the same appData and outcome as all other variable parts in finalization proof.\n     * @param numStates The number of states in the finalization proof.\n     * @param whoSignedWhat An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\n     * @param sigs An array of signatures that support the state with the `largestTurnNum`: one for each participant, in participant order (e.g. [sig of participant[0], sig of participant[1], ...]).\n     */\n    function conclude(\n        FixedPart memory fixedPart,\n        IForceMoveApp.VariablePart memory latestVariablePart,\n        uint8 numStates,\n        uint8[] memory whoSignedWhat,\n        Signature[] memory sigs\n    ) external;\n\n    // events\n\n    /**\n     * @dev Indicates that a challenge has been registered against `channelId`.\n     * @param channelId Unique identifier for a state channel.\n     * @param turnNumRecord A turnNum that (the adjudicator knows) is supported by a signature from each participant.\n     * @param finalizesAt The unix timestamp when `channelId` will finalize.\n     * @param isFinal Boolean denoting whether the challenge state is final.\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\n     * @param variableParts An ordered array of structs, each decribing the properties of the state channel that may change with each state update.\n     * @param sigs A list of Signatures that supported the challenge: one for each participant, in participant order (e.g. [sig of participant[0], sig of participant[1], ...]).\n     * @param whoSignedWhat Indexing information to identify which signature was by which participant\n     */\n    event ChallengeRegistered(\n        bytes32 indexed channelId,\n        uint48 turnNumRecord,\n        uint48 finalizesAt,\n        bool isFinal,\n        FixedPart fixedPart,\n        IForceMoveApp.VariablePart[] variableParts,\n        Signature[] sigs,\n        uint8[] whoSignedWhat\n    );\n\n    /**\n     * @dev Indicates that a challenge, previously registered against `channelId`, has been cleared.\n     * @param channelId Unique identifier for a state channel.\n     * @param newTurnNumRecord A turnNum that (the adjudicator knows) is supported by a signature from each participant.\n     */\n    event ChallengeCleared(bytes32 indexed channelId, uint48 newTurnNumRecord);\n\n    /**\n     * @dev Indicates that a challenge has been registered against `channelId`.\n     * @param channelId Unique identifier for a state channel.\n     * @param finalizesAt The unix timestamp when `channelId` finalized.\n     */\n    event Concluded(bytes32 indexed channelId, uint48 finalizesAt);\n}\n"
    },
    "contracts/StateChannel/StatusManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport './interfaces/IStatusManager.sol';\n\n/**\n * @dev The StatusManager is responsible for on-chain storage of the status of active channels\n */\ncontract StatusManager is IStatusManager {\n    mapping(bytes32 => bytes32) public statusOf;\n\n    /**\n     * @notice Computes the ChannelMode for a given channelId.\n     * @dev Computes the ChannelMode for a given channelId.\n     * @param channelId Unique identifier for a channel.\n     */\n    function _mode(bytes32 channelId) internal view returns (ChannelMode) {\n        // Note that _unpackStatus(someRandomChannelId) returns (0,0,0), which is\n        // correct when nobody has written to storage yet.\n\n        (, uint48 finalizesAt, ) = _unpackStatus(channelId);\n        if (finalizesAt == 0) {\n            return ChannelMode.Open;\n            // solhint-disable-next-line not-rely-on-time\n        } else if (finalizesAt <= block.timestamp) {\n            return ChannelMode.Finalized;\n        } else {\n            return ChannelMode.Challenge;\n        }\n    }\n\n    /**\n     * @notice Formats the input data for on chain storage.\n     * @dev Formats the input data for on chain storage.\n     * @param channelData ChannelData data.\n     */\n    function _generateStatus(ChannelData memory channelData)\n        internal\n        pure\n        returns (bytes32 status)\n    {\n        // The hash is constructed from left to right.\n        uint256 result;\n        uint16 cursor = 256;\n\n        // Shift turnNumRecord 208 bits left to fill the first 48 bits\n        result = uint256(channelData.turnNumRecord) << (cursor -= 48);\n\n        // logical or with finalizesAt padded with 160 zeros to get the next 48 bits\n        result |= (uint256(channelData.finalizesAt) << (cursor -= 48));\n\n        // logical or with the last 160 bits of the hash the remaining channelData fields\n        // (we call this the fingerprint)\n        result |= uint256(_generateFingerprint(channelData.stateHash, channelData.outcomeHash));\n\n        status = bytes32(result);\n    }\n\n    function _generateFingerprint(bytes32 stateHash, bytes32 outcomeHash)\n        internal\n        pure\n        returns (uint160)\n    {\n        return uint160(uint256(keccak256(abi.encode(stateHash, outcomeHash))));\n    }\n\n    /**\n     * @notice Unpacks turnNumRecord, finalizesAt and fingerprint from the status of a particular channel.\n     * @dev Unpacks turnNumRecord, finalizesAt and fingerprint from the status of a particular channel.\n     * @param channelId Unique identifier for a state channel.\n     * @return turnNumRecord A turnNum that (the adjudicator knows) is supported by a signature from each participant.\n     * @return finalizesAt The unix timestamp when `channelId` will finalize.\n     * @return fingerprint The last 160 bits of kecca256(stateHash, outcomeHash)\n     */\n    function _unpackStatus(bytes32 channelId)\n        internal\n        view\n        returns (\n            uint48 turnNumRecord,\n            uint48 finalizesAt,\n            uint160 fingerprint\n        )\n    {\n        bytes32 status = statusOf[channelId];\n        uint16 cursor = 256;\n        turnNumRecord = uint48(uint256(status) >> (cursor -= 48));\n        finalizesAt = uint48(uint256(status) >> (cursor -= 48));\n        fingerprint = uint160(uint256(status));\n    }\n}\n"
    },
    "contracts/StateChannel/interfaces/IStatusManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\ninterface IStatusManager {\n    enum ChannelMode {\n        Open,\n        Challenge,\n        Finalized\n    }\n\n    struct ChannelData {\n        uint48 turnNumRecord;\n        uint48 finalizesAt;\n        bytes32 stateHash; // keccak256(abi.encode(State))\n        bytes32 outcomeHash;\n    }\n}\n"
    },
    "contracts/StateChannel/test/TESTForceMove.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\nimport '../ForceMove.sol';\n\n/**\n * @dev This contract extends the ForceMove contract to enable it to be more easily unit-tested. It exposes public or external functions that set storage variables or wrap otherwise internal functions. It should not be deployed in a production environment.\n */\ncontract TESTForceMove is ForceMove {\n    // Public wrappers for internal methods:\n\n    /**\n     * @dev Wrapper for otherwise internal function. Tests whether a given address is in a given array of addresses.\n     * @param suspect A single address of interest.\n     * @param addresses A line-up of possible perpetrators.\n     * @return true if the address is in the array, false otherwise\n     */\n    function isAddressInArray(address suspect, address[] memory addresses)\n        public\n        pure\n        returns (bool)\n    {\n        return _isAddressInArray(suspect, addresses);\n    }\n\n    /**\n     * @dev Wrapper for otherwise internal function. Given an array of state hashes, checks the validity of the supplied signatures. Valid means there is a signature for each participant, either on the hash of the state for which they are a mover, or on the hash of a state that appears after that state in the array.\n     * @param largestTurnNum The largest turn number of the submitted states; will overwrite the stored value of `turnNumRecord`.\n     * @param participants A list of addresses representing the participants of a channel.\n     * @param stateHashes Array of keccak256(State) submitted in support of a state,\n     * @param sigs Array of Signatures, one for each participant\n     * @param whoSignedWhat participant[i] signed stateHashes[whoSignedWhat[i]]\n     * @return true if the signatures are valid, false otherwise\n     */\n    function validSignatures(\n        uint48 largestTurnNum,\n        address[] memory participants,\n        bytes32[] memory stateHashes,\n        Signature[] memory sigs,\n        uint8[] memory whoSignedWhat // whoSignedWhat[i] is the index of the state in stateHashes that was signed by participants[i]\n    ) public pure returns (bool) {\n        return _validSignatures(largestTurnNum, participants, stateHashes, sigs, whoSignedWhat);\n    }\n\n    /**\n     * @dev Wrapper for otherwise internal function. Given a declaration of which state in the support proof was signed by which participant, check if this declaration is acceptable. Acceptable means there is a signature for each participant, either on the hash of the state for which they are a mover, or on the hash of a state that appears after that state in the array.\n     * @param whoSignedWhat participant[i] signed stateHashes[whoSignedWhat[i]]\n     * @param largestTurnNum Largest turnNum of the support proof\n     * @param nParticipants Number of participants in the channel\n     * @param nStates Number of states in the support proof\n     * @return true if whoSignedWhat is acceptable, false otherwise\n     */\n    function acceptableWhoSignedWhat(\n        uint8[] memory whoSignedWhat,\n        uint48 largestTurnNum,\n        uint256 nParticipants,\n        uint256 nStates\n    ) public pure returns (bool) {\n        return _acceptableWhoSignedWhat(whoSignedWhat, largestTurnNum, nParticipants, nStates);\n    }\n\n    /**\n     * @dev Wrapper for otherwise internal function. Given a digest and digital signature, recover the signer\n     * @param _d message digest\n     * @param sig ethereum digital signature\n     * @return signer\n     */\n    function recoverSigner(bytes32 _d, Signature memory sig) public pure returns (address) {\n        return _recoverSigner(_d, sig);\n    }\n\n    // public setter for statusOf\n\n    /**\n     * @dev Manually set the fingerprint for a given channelId.  Shortcuts the public methods (ONLY USE IN A TESTING ENVIRONMENT).\n     * @param channelId Unique identifier for a state channel.\n     * @param channelData The channelData to be formatted and stored against the channelId\n     */\n    function setStatusFromChannelData(bytes32 channelId, ChannelData memory channelData) public {\n        if (channelData.finalizesAt == 0) {\n            require(\n                channelData.stateHash == bytes32(0) && channelData.outcomeHash == bytes32(0),\n                'Invalid open channel'\n            );\n        }\n\n        statusOf[channelId] = _generateStatus(channelData);\n    }\n\n    /**\n     * @dev Manually set the fingerprint for a given channelId.  Shortcuts the public methods (ONLY USE IN A TESTING ENVIRONMENT).\n     * @param channelId Unique identifier for a state channel.\n     * @param f The fingerprint to store against the channelId\n     */\n    function setStatus(bytes32 channelId, bytes32 f) public {\n        statusOf[channelId] = f;\n    }\n\n    /**\n     * @dev Wrapper for otherwise internal function. Hashes the input data and formats it for on chain storage.\n     * @param channelData ChannelData data.\n     */\n    function generateStatus(ChannelData memory channelData)\n        public\n        pure\n        returns (bytes32 newStatus)\n    {\n        return _generateStatus(channelData);\n    }\n\n    /**\n     * @dev Wrapper for otherwise internal function. Checks that a given ChannelData struct matches a supplied bytes32 when formatted for storage.\n     * @param cs A given ChannelData data structure.\n     * @param f Some data in on-chain storage format.\n     */\n    function matchesStatus(ChannelData memory cs, bytes32 f) public pure returns (bool) {\n        return _matchesStatus(cs, f);\n    }\n\n    /**\n     * @dev Wrapper for otherwise internal function. Checks that a given channel is in the Challenge mode.\n     * @param channelId Unique identifier for a channel.\n     */\n    function requireChannelOpen(bytes32 channelId) public view {\n        _requireChannelOpen(channelId);\n    }\n}\n"
    },
    "contracts/StateChannel/test/TESTAdjudicator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\nimport '../Adjudicator.sol';\nimport './TESTForceMove.sol';\n\n/**\n * @dev This contract extends the NitroAdjudicator contract to enable it to be more easily unit-tested. It exposes public or external functions that set storage variables or wrap otherwise internal functions. It should not be deployed in a production environment.\n */\ncontract TESTAdjudicator is Adjudicator, TESTForceMove {\n    /**\n     * @dev Manually set the holdings mapping to a given amount for a given channelId.  Shortcuts the deposit workflow (ONLY USE IN A TESTING ENVIRONMENT)\n     * @param channelId Unique identifier for a state channel.\n     * @param amount The number of assets that should now be \"escrowed: against channelId\n     */\n    function setHoldings(\n        address asset,\n        bytes32 channelId,\n        uint256 amount\n    ) external {\n        holdings[asset][channelId] = amount;\n    }\n\n    /**\n     * @dev Wrapper for otherwise internal function. Checks if a given destination is external (and can therefore have assets transferred to it) or not.\n     * @param destination Destination to be checked.\n     * @return True if the destination is external, false otherwise.\n     */\n    function isExternalDestination(bytes32 destination) public pure returns (bool) {\n        return _isExternalDestination(destination);\n    }\n\n    /**\n     * @dev Wrapper for otherwise internal function. Converts an ethereum address to a nitro external destination.\n     * @param participant The address to be converted.\n     * @return The input address left-padded with zeros.\n     */\n    function addressToBytes32(address participant) public pure returns (bytes32) {\n        return _addressToBytes32(participant);\n    }\n}\n"
    },
    "contracts/StateChannel/Adjudicator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport './ForceMove.sol';\nimport {ExitFormat as Outcome} from '@statechannels/exit-format/contracts/ExitFormat.sol';\nimport './MultiAssetHolder.sol';\n\n/**\n * @dev The Adjudicator contract extends MultiAssetHolder and ForceMove\n */\ncontract Adjudicator is ForceMove, MultiAssetHolder {\n    /**\n     * @notice Finalizes a channel by providing a finalization proof, and liquidates all assets for the channel.\n     * @dev Finalizes a channel by providing a finalization proof, and liquidates all assets for the channel.\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\n     * @param latestVariablePart Latest variable part in finalization proof. Must have the largest turnNum and the same appData and outcome as all other variable parts in finalization proof.\n     * @param numStates The number of states in the finalization proof.\n     * @param whoSignedWhat An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\n     * @param sigs Array of signatures, one for each participant, in participant order (e.g. [sig of participant[0], sig of participant[1], ...]).\n     */\n    function concludeAndTransferAllAssets(\n        FixedPart memory fixedPart,\n        IForceMoveApp.VariablePart memory latestVariablePart,\n        uint8 numStates,\n        uint8[] memory whoSignedWhat,\n        Signature[] memory sigs\n    ) public {\n        bytes32 channelId = _conclude(\n            fixedPart,\n            latestVariablePart,\n            numStates,\n            whoSignedWhat,\n            sigs\n        );\n\n        transferAllAssets(channelId, latestVariablePart.outcome, bytes32(0));\n    }\n\n    /**\n     * @notice Liquidates all assets for the channel\n     * @dev Liquidates all assets for the channel\n     * @param channelId Unique identifier for a state channel\n     * @param outcome An array of SingleAssetExit[] items.\n     * @param stateHash stored state hash for the channel\n     */\n    function transferAllAssets(\n        bytes32 channelId,\n        Outcome.SingleAssetExit[] memory outcome,\n        bytes32 stateHash\n    ) public {\n        // checks\n        _requireChannelFinalized(channelId);\n        _requireMatchingFingerprint(stateHash, _hashOutcome(outcome), channelId);\n\n        // computation\n        bool allocatesOnlyZerosForAllAssets = true;\n        Outcome.SingleAssetExit[] memory exit = new Outcome.SingleAssetExit[](outcome.length);\n        uint256[] memory initialHoldings = new uint256[](outcome.length);\n        uint256[] memory totalPayouts = new uint256[](outcome.length);\n        for (uint256 assetIndex = 0; assetIndex < outcome.length; assetIndex++) {\n            Outcome.SingleAssetExit memory assetOutcome = outcome[assetIndex];\n            Outcome.Allocation[] memory allocations = assetOutcome.allocations;\n            address asset = outcome[assetIndex].asset;\n            initialHoldings[assetIndex] = holdings[asset][channelId];\n            (\n                Outcome.Allocation[] memory newAllocations,\n                bool allocatesOnlyZeros,\n                Outcome.Allocation[] memory exitAllocations,\n                uint256 totalPayoutsForAsset\n            ) = compute_transfer_effects_and_interactions(\n                    initialHoldings[assetIndex],\n                    allocations,\n                    new uint256[](0)\n                );\n            if (!allocatesOnlyZeros) allocatesOnlyZerosForAllAssets = false;\n            totalPayouts[assetIndex] = totalPayoutsForAsset;\n            outcome[assetIndex].allocations = newAllocations;\n            exit[assetIndex] = Outcome.SingleAssetExit(\n                asset,\n                assetOutcome.metadata,\n                exitAllocations\n            );\n        }\n\n        // effects\n        for (uint256 assetIndex = 0; assetIndex < outcome.length; assetIndex++) {\n            address asset = outcome[assetIndex].asset;\n            holdings[asset][channelId] -= totalPayouts[assetIndex];\n            emit AllocationUpdated(channelId, assetIndex, initialHoldings[assetIndex]);\n        }\n\n        if (allocatesOnlyZerosForAllAssets) {\n            delete statusOf[channelId];\n        } else {\n            _updateFingerprint(channelId, stateHash, _hashOutcome(outcome));\n        }\n\n        // interactions\n        _executeExit(exit);\n    }\n\n    /**\n    * @notice Check that the submitted pair of states form a valid transition (public wrapper for internal function _requireValidTransition)\n    * @dev Check that the submitted pair of states form a valid transition (public wrapper for internal function _requireValidTransition)\n    * @param nParticipants Number of participants in the channel.\n    transition\n    * @param ab Variable parts of each of the pair of states\n    * @param appDefinition Address of deployed contract containing application-specific validTransition function.\n    * @return true if the later state is a validTransition from its predecessor, reverts otherwise.\n    */\n    function validTransition(\n        uint256 nParticipants,\n        IForceMoveApp.VariablePart[2] memory ab, // [a,b]\n        address appDefinition\n    ) public pure returns (bool) {\n        return _requireValidTransition(nParticipants, ab, appDefinition);\n    }\n\n    /**\n     * @notice Executes an exit by paying out assets and calling external contracts\n     * @dev Executes an exit by paying out assets and calling external contracts\n     * @param exit The exit to be paid out.\n     */\n    function _executeExit(Outcome.SingleAssetExit[] memory exit) internal {\n        for (uint256 assetIndex = 0; assetIndex < exit.length; assetIndex++) {\n            _executeSingleAssetExit(exit[assetIndex]);\n        }\n    }\n}\n"
    },
    "contracts/CommitReveal/ExampleCommitRevealApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * Created on 2022-06-02 12:37\n * @summary: An example commit-reveal randomness application. It is a simple battle game where\n * players can attack, defend or drink coffee. The player with the highest speed state (obtained from drinking the most coffee)\n * gets to attack first each turn. If the players speed is equal then the combined random seed is used to randomly select which \n * player is first.\n * @author: Willem Olding (ChainSafe)\n */\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport './CommitRevealApp.sol';\n\nstruct GameState {\n    PlayerState[2] players;\n}\n\nstruct PlayerState {\n    uint8 health;\n    uint8 speed;\n}\n\ncontract ExampleCommitRevealApp is CommitRevealApp {\n    using SafeMath for uint8;\n\n    enum Move { ATTACK, DEFEND, COFFEE }\n\n    // the damage done in each case, can adjust for balance\n    uint8 constant MINIMAL_ATTACK = 2;\n    uint8 constant ATTACK = 5;\n    uint8 constant COFFEE_SPEED_INCREASE = 1;\n\n    function _gameState(bytes memory gameStateBytes) internal pure returns (GameState memory) {\n        return abi.decode(gameStateBytes, (GameState));\n    }\n\n    function _attack(GameState memory gameState, uint8 receiver, uint8 damage) internal pure returns (GameState memory) {\n        gameState.players[receiver].health -= damage;\n        return (gameState);\n    }\n\n    function _speedUp(GameState memory gameState, uint8 receiver, uint8 increase) internal pure returns (GameState memory) {\n        gameState.players[receiver].speed += increase;\n        return (gameState);\n    }\n\n    function _resolveBothAttack(GameState memory gameState, uint8 firstMover) internal pure returns (GameState memory) {\n        gameState = _attack(gameState, ~firstMover, ATTACK);\n        if (gameState.players[~firstMover].health > 0) {  // other player attacks only if still alive\n            gameState = _attack(gameState, firstMover, ATTACK);\n        }\n        return (gameState);\n    }\n\n    function advanceState(\n        bytes memory _gameState_,\n        Outcome.SingleAssetExit[] memory outcome,\n        uint8 _moveA,\n        uint8 _moveB,\n        bytes32 randomSeed\n    ) override public pure returns (bytes memory, Outcome.SingleAssetExit[] memory, bool) {\n        GameState memory gameState = _gameState(_gameState_);\n\n        Move moveA = Move(_moveA);\n        Move moveB = Move(_moveB);\n\n        // enumerate all the combinations\n        if        (moveA == Move.ATTACK && moveB == Move.ATTACK) {\n            // Both attack, fastest player hits first\n            if (gameState.players[A].speed > gameState.players[B].speed) {\n                gameState = _resolveBothAttack(gameState, A);\n            } else if (gameState.players[B].speed > gameState.players[A].speed) {\n                gameState = _resolveBothAttack(gameState, B);\n            } else { // speeds are evenly matched. Randomly choose who goes first\n                if (uint(randomSeed) % 2 == 0) {\n                    gameState = _resolveBothAttack(gameState, A);\n                } else {\n                    gameState =_resolveBothAttack(gameState, B);\n                }\n            }\n        } else if (moveA == Move.ATTACK && moveB == Move.DEFEND) {\n            // A lands minimal attack on B\n             gameState = _attack(gameState, B, MINIMAL_ATTACK);\n        } else if (moveA == Move.ATTACK && moveB == Move.COFFEE) {\n            // A lands big attack\n            gameState = _attack(gameState, B, ATTACK);\n        } else if (moveA == Move.DEFEND && moveB == Move.ATTACK) {\n            // B lands minimal attack on A\n             gameState = _attack(gameState, A, MINIMAL_ATTACK);\n        } else if (moveA == Move.DEFEND && moveB == Move.DEFEND) {\n            // Nothing happens...\n        } else if (moveA == Move.DEFEND && moveB == Move.COFFEE) {\n            // B speed goes up\n            gameState = _speedUp(gameState, B, COFFEE_SPEED_INCREASE);\n        } else if (moveA == Move.COFFEE && moveB == Move.ATTACK) {\n            // B lands big attack\n            gameState = _attack(gameState, A, ATTACK);\n        } else if (moveA == Move.COFFEE && moveB == Move.DEFEND) {\n            // A speed goes up\n            gameState = _speedUp(gameState, A, COFFEE_SPEED_INCREASE);\n        } else if (moveA == Move.COFFEE && moveB == Move.COFFEE) {\n            // A and B speed goes up\n            gameState = _speedUp(gameState, A, COFFEE_SPEED_INCREASE);\n            gameState = _speedUp(gameState, B, COFFEE_SPEED_INCREASE);\n        }\n\n        // check if the game is concluded and update the conclude flag and outcome\n        // as required\n        if (gameState.players[A].health == 0) {\n            return (abi.encode(gameState), updateOutcomeFavourPlayer(outcome, A), true);\n        } else if (gameState.players[A].health == 0) {\n            return (abi.encode(gameState), updateOutcomeFavourPlayer(outcome, B), true);\n        } else {\n            return (abi.encode(gameState), outcome, false);\n        }\n\n\n    }\n\n    // For incentive reasons it needs to ensure that each time a player makes\n    // a state update they set themselves as the winning player\n    // unless the game forces otherwise via a conclusion\n    // \n    // The entire balance is reallocated to the winning player index by this function\n    // \n    // This assumes the outcome is ordered according to the players.\n    function updateOutcomeFavourPlayer(\n        Outcome.SingleAssetExit[] memory outcome,\n        uint8 playerIndex\n    ) override public pure returns (Outcome.SingleAssetExit[] memory) {\n        Outcome.SingleAssetExit memory assetExit = outcome[0];\n        uint256 total = assetExit.allocations[0].amount + assetExit.allocations[1].amount;\n\n        outcome[0].allocations[playerIndex].amount = total;\n        outcome[0].allocations[~playerIndex].amount = 0;\n\n        return (outcome);\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000,
      "details": {
        "yul": true,
        "yulDetails": {
          "stackAllocation": true,
          "optimizerSteps": "dhfoDgvulfnTUtnIf"
        }
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}